<!DOCTYPE HTML>
<html>

<!-- Borksy 4.2 -->
<!-- Bitsy 6.4 -->

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>The Case Of The Missing Slice: A Dream In Whipped Cream</title>

<script type="text/bitsyGameData" id="exportedGameData">
The Case Of The Missing Slice: A Dream In Whipped Cream

# BITSY VERSION 6.4

! ROOM_FORMAT 1

PAL 0
255,190,87
255,118,61
255,73,0

ROOM 7
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,1,0,2,0,2,0,3,4,0,5,6,7,8,9,a
a,17,0,18,0,19,1a,1b,1c,1d,1e,1f,1f,1f,k,a
a,1g,0,2,0,1h,1i,1j,1k,1l,1m,1n,1o,1p,k,a
a,1q,1r,1s,1t,1u,1v,1w,0,1x,1y,1z,20,21,k,a
a,22,23,24,25,26,27,28,0,29,1,2a,2b,2c,2d,a
a,2e,2f,2g,2h,2i,2j,2k,2l,2m,2n,2l,2o,2p,2q,a
a,2r,2s,2t,2,2u,2v,2w,0,2x,2y,0,0,0,2z,a
a,30,2,2t,31,32,0,0,0,0,0,0,0,0,33,a
a,2t,34,35,36,0,0,0,0,0,0,0,0,0,37,a
a,38,39,0,0,0,0,0,0,0,0,0,0,0,3a,a
a,3b,0,0,0,0,0,0,0,0,0,0,0,0,3c,a
a,a,a,a,a,a,a,a,a,a,a,0,0,0,a,a
a,a,a,a,a,a,a,a,a,a,a,a,w,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
NAME kitchen
ITM 2 9,5
EXT 12,13 10 14,7
PAL 0

ROOM 8
a,a,3d,3e,3e,3e,3e,3e,3e,3e,3e,3e,3e,3f,a,a
a,a,3g,0,0,3h,3i,3j,3k,3l,0,0,0,3m,a,a
a,a,3g,0,0,3n,0,0,0,3o,3p,0,0,3m,a,a
a,a,3g,0,0,2t,0,3q,3r,3s,3t,0,0,3m,a,a
a,a,3g,0,0,3u,0,3v,3w,3x,3y,0,0,3m,a,a
a,a,3g,0,0,3z,0,0,40,41,42,0,0,3m,a,a
a,a,3g,0,0,43,44,0,45,46,47,0,0,3m,a,a
a,a,3g,0,0,48,49,4a,4b,4c,4d,0,0,3m,a,a
a,a,3g,0,4e,4f,4g,4h,0,4i,0,0,0,3m,a,a
a,a,3g,4j,4k,a,4l,4m,4n,4o,4p,0,0,3m,a,a
a,a,3g,a,a,a,a,4q,4r,4s,a,4t,4u,3m,a,a
a,a,3g,a,a,a,a,4v,4w,4x,4y,a,4z,3m,a,a
a,a,3g,a,a,a,a,50,51,52,53,a,a,3m,a,a
a,a,3g,a,a,a,a,a,r7,a,54,a,a,3m,a,a
a,a,55,56,56,56,56,56,r8,56,57,56,56,58,a,a
a,a,a,a,a,a,a,a,w,a,a,a,a,a,a,a
NAME portrait
EXT 8,15 13 13,5
PAL 0

ROOM 10
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a6,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a7,a,a8,a9,a,a,a,a,a,a,a,a
a,a,a,a,aa,ab,0,0,a,a,a,a,a,a,a,a
a,a,a,a,a,a,0,0,a,ac,a,ad,ae,af,ag,a
a,ah,ai,0,ak,a,0,0,a,al,a,am,an,ao,ap,a
a,aq,ar,0,as,a,0,0,a,at,a,au,av,0,aw,a
a,a,a,ax,a,a,a,ax,a,ax,ay,az,a,a,0,a
a,a,a,0,0,b0,b1,0,0,0,0,0,0,0,0,b2
a,b3,b4,ax,a,a,0,0,0,0,0,0,0,b5,b6,b7
a,b8,b9,0,0,a,0,0,0,ba,bb,a,ax,a,a,a
a,bc,bd,0,0,a,0,0,0,be,bf,a,0,bg,bh,a
a,bi,bj,bk,0,a,bl,bm,bn,bo,bp,a,bq,br,bs,a
a,bt,bu,bv,bw,a,bx,by,bz,c0,c1,a,c2,c3,bw,a
a,a,a,a,a,a,a,c4,c5,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
NAME birds_eye
EXT 8,11 13 6,9
EXT 3,7 12 10,6
EXT 14,7 7 12,13
EXT 3,9 14 12,4
EXT 11,8 13 0,10
EXT 6,8 13 15,10
PAL 0

ROOM 12
dq,dr,ds,dt,du,dv,dw,a,a,a,a,a,a,a,a,a
dx,dy,dz,dz,e0,e1,e2,e3,e4,0,e5,2t,a,a,a,a
e6,e7,0,0,k,e8,e9,ea,eb,0,ec,2t,a,a,a,a
ed,ee,ef,eg,k,0,0,eh,ei,0,ej,ek,a,a,a,a
el,em,en,eo,ep,eq,er,es,et,eu,0,0,a,a,a,a
ev,ew,ex,ey,ez,f0,f1,f2,f3,f4,0,0,a,a,a,a
a,f5,f6,f7,f8,f9,fa,fb,fc,fd,w,a,a,a,a,a
a,fe,ff,fg,fh,fi,fj,fk,fl,fm,a,a,a,a,a,a
a,fn,fo,fp,fq,fr,fs,ft,fu,fv,a,a,a,a,a,a
a,4z,fw,fx,a,fy,4k,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,5z
NAME caitlyns_bedroom
EXT 10,6 10 3,7
PAL 0

ROOM 13
fz,g0,g1,g2,a,a,a,a,a,a,a,g3,g4,g5,g6,g7
g8,g9,ga,gb,a,a,a,a,a,a,a,gc,gd,ge,gf,gg
gh,gi,gj,gk,a,a,a,a,a,gl,gm,gn,go,7a,7a,gp
gq,gr,a,gs,a,a,a,a,5z,gt,gu,a,a,a,a,a
a,gv,gw,gx,gx,gy,gz,a,h0,h1,a,a,a,a,a,a
h2,h3,a,5z,h4,h5,h6,a,h7,h8,h9,ha,ha,hb,hc,hd
a,a,he,hf,hg,hh,hi,hj,hk,hl,hm,hn,hn,hn,ho,hp
r7,hq,hr,hs,ht,ht,hu,0,hv,hw,hx,hy,hy,hz,i0,hw
i1,i2,i3,i4,i5,i5,0,0,i6,i7,i7,i7,i7,i8,i9,i7
cn,ia,ib,1,0,0,0,0,0,0,0,0,0,0,0,0
0,0,ic,0,0,0,0,0,0,0,0,0,0,0,0,0
id,ie,if,p,p,ig,ih,ii,0,0,0,0,0,0,0,0
ij,ik,il,im,in,io,ip,iq,ir,is,it,iu,iv,iw,ix,iy
iz,j0,j1,j2,j3,a,a,j4,j5,j6,j7,j8,j9,ja,jb,jc
jd,je,jf,jg,a,a,a,jh,ji,jj,jk,jl,jm,jn,jo,jp
jq,jr,js,jt,ju,jv,jw,jx,jy,jz,k0,k1,k2,k3,k4,k5
NAME living_room
ITM 0 0,7
EXT 6,9 10 8,11
EXT 13,5 8 8,15
EXT 0,10 10 11,8
EXT 15,10 10 6,8
PAL 0

ROOM 14
a,a,a,a,a,a,a,a,k6,k7,k8,a,a,a,a,a
a,k9,ka,ka,kb,0,kc,kd,ke,kf,kg,a,a,a,a,a
kh,ki,kj,kk,kl,0,ht,km,kn,ko,kp,a,a,a,a,a
2,kq,kr,ks,kt,0,ht,ku,kv,kw,kx,a,a,a,a,a
ky,kz,0,0,l0,0,l1,l2,l3,l4,l5,a,n4,a,a,a
l6,l7,0,0,l8,0,0,l9,la,8z,lb,0,0,a,lc,a
ld,le,0,0,lf,0,0,6c,0,0,lg,0,0,lh,li,a
lj,lk,ll,ll,lm,0,0,0,0,0,0,0,0,ln,lo,a
lp,lq,lr,ls,0,0,0,lt,0,0,0,0,0,lu,lv,a
lw,lx,ly,lz,m0,0,m1,m2,m3,0,0,0,0,m4,a,a
m5,m6,m7,m8,m9,ma,mb,mc,md,me,0,0,0,mf,a,a
a,mg,mh,mi,mj,mk,ml,mm,mn,mo,mp,0,mq,mr,a,a
a,ms,mt,mu,mv,mw,mx,my,mz,n0,n1,n2,n3,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
NAME lishas bedroom
EXT 12,4 10 3,9
PAL 0

ROOM 15
0,0,0,n5,n6,n7,n8,n9,na,nb,nc,nd,0,0,0,0
0,0,0,ne,nf,a,ng,nh,a,ni,hp,nj,nk,nl,nm,0
nn,no,qy,nq,nr,ns,nt,nu,nv,nw,nx,4k,a,a,ny,nz
o0,a,a,a,a,o1,o2,o3,o4,o5,a,a,a,a,a,o6
o7,a,a,a,a,o8,o9,oa,ob,oc,od,a,a,a,a,oe
of,a,a,og,oh,oi,oj,ok,ol,om,on,oo,a,a,op,oq
qz,a,os,ot,ou,ov,36,ow,ox,oy,oz,p0,p1,a,a,a
r0,a,p3,a,p4,ce,ce,ce,p5,dz,dz,p6,p7,p8,a,a
r1,a,pa,pb,pc,bw,bw,pd,pe,pf,pf,pf,pg,gu,5z,ph
r2,a,a,4z,pj,pk,pl,pm,pn,po,pp,pq,pr,a,ps,0
r3,pu,a,a,a,a,gx,gx,pv,pw,4k,a,a,a,px,0
0,py,pz,pz,r4,q1,a,a,a,q2,r5,q4,56,q5,q6,0
0,0,0,0,0,6c,q7,pz,r6,36,q9,qa,qb,0,0,0
0,0,0,0,0,0,0,0,0,qc,qd,qe,qf,0,0,0
0,0,0,0,0,0,0,0,qg,qh,qi,0,0,0,0,0
0,0,0,0,0,0,0,0,qj,0,0,0,0,0,0,0
NAME dream
ITM 1 7,14
EXT 6,15 14 1,3
PAL 0

TIL 1
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME kitchen 1

TIL 2
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00000100
NAME kitchen 2

TIL 3
00100000
00100000
00100000
00100000
00100000
00100001
00100001
00100001
NAME kitchen 3

TIL 4
00000000
00000000
00000000
00000000
00011111
11110101
01010111
01110101
NAME kitchen 4

TIL 5
00000000
00000000
00000000
00000000
00000001
00000011
00000011
00000011
NAME kitchen 5

TIL 6
00001110
00001010
00001010
11111010
10111011
00100000
00100000
00100000
NAME kitchen 6

TIL 7
00101000
00101000
01001100
11000101
11000101
01000111
01000100
01000100
NAME kitchen 7

TIL 8
00000101
00001101
01111000
11011000
11011000
01011000
01011000
01011000
NAME kitchen 8

TIL 9
11111111
11111111
11111110
11111100
11111000
11110000
11100000
11000000
NAME kitchen 9

TIL 10
00001000
00000100
00000010
00000001
00000000
00000000
00000000
00000000

TIL 11
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00010000

TIL 12
00011000
00010100
00010010
00010001
00010000
00010000
00010000
00010000

TIL 13
00011111
00100000
01000000
10000000
00000000
00000000
00000000
00000000

TIL 14
00000000
00000000
00000000
00000000
00000001
00000010
00000100
00001000

TIL 15
11111111
00000001
00000001
00000010
00000100
00001000
00010000
00100000

TIL 16
00000000
00000000
00000000
00000001
00000010
00000100
00001000
00010000

TIL 17
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00001010
NAME kitchen 10

TIL 18
00000100
00000100
00000100
00000100
00000100
00010100
00110100
00000100
NAME kitchen 11

TIL 19
00000100
00000100
00000100
00000100
00100100
01100100
00000100
00000100
NAME kitchen 12

TIL 20
00000000
00000000
00000000
00001111
00001010
00001000
00001010
00001000
NAME kitchen 39

TIL 21
00000000
00000000
10000000
11111000
10001000
00101000
00001000
10101000
NAME kitchen 40

TIL 22
00000000
00000000
00000000
00000111
01111000
10000111
00011111
00001111
NAME kitchen 41

TIL 23
00000000
00000111
01111000
10001110
00111111
10011110
11000000
10000111
NAME kitchen 42

TIL 24
01111111
10000111
00000000
00000000
00000000
00000000
11100111
11111000
NAME kitchen 43

TIL 25
11111111
11111110
00000000
00000011
00011100
11100100
00000100
00000100
NAME kitchen 44

TIL 26
11000001
00001110
01110000
10000000
00000000
00000000
00000000
00000000
NAME kitchen 45

TIL 27
11000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME kitchen 46

TIL 28
00100000
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME kitchen 47

TIL 29
00100000
00100000
00100000
00100000
00100000
00100000
01100000
01000000
NAME kitchen 48

TIL 30
00001110
00110000
11000000
10000000
10000000
10000000
10000000
10000000
NAME kitchen 75

TIL 31
00000100
00000100
00000100
00000100
00000111
00000100
00011000
00100000
NAME kitchen 76

TIL 32
00001100
00010000
01100000
10000000
00000000
00000000
00000000
00000000
NAME kitchen 77

TIL 33
00111111
00111111
00111111
00111111
00111111
00011111
00011111
00011111
NAME kitchen 78

TIL 34
00000100
00000100
00000100
00000100
00000100
00011000
01100000
10000011
NAME kitchen 79

TIL 35
10000000
10000001
10000110
10001000
10010000
11100000
10000000
00000000
NAME kitchen 80

TIL 36
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 81

TIL 37
00011111
00011111
00001111
00001111
00001111
00001111
00001111
00000111
NAME kitchen 82

TIL 38
10000011
10000100
10011000
01100000
10000001
00000010
00001100
00010000
NAME kitchen 83

TIL 39
00000100
00011000
00100000
01000000
10000000
00000000
00000000
00000000
NAME kitchen 84

TIL 40
00000000
00000000
00001100
00011000
00010000
00000000
00000000
00000000
NAME kitchen 24

TIL 41
00000001
00111011
01101110
01000000
00000000
00000000
00000000
00000011
NAME kitchen 25

TIL 42
10010000
00010000
10010000
11010000
01010000
00010000
00010000
11010000
NAME kitchen 26

TIL 43
00000110
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 27

TIL 44
01000000
11000000
10000000
10010000
10010000
10011000
10001100
10000110
NAME kitchen 28

TIL 45
00000000
00000000
00000011
00000000
00000000
00000000
00000000
00000000
NAME kitchen 29

TIL 46
01111111
11001111
10100000
00111111
00000000
00000000
00000000
00000000
>
01111111
11001111
10101111
00110000
00011111
00000000
00000000
00000000
NAME kitchen 30

TIL 47
01110000
01110000
11010000
10100000
00100000
00100000
00100000
00100000
NAME kitchen 31

TIL 48
00000000
00000000
00000000
00000000
00000001
00000011
00000010
00000111
NAME kitchen 32

TIL 49
10000011
10000000
10000000
11000000
11100000
00100000
00010000
00011000
NAME kitchen 33

TIL 50
11111110
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME kitchen 60

TIL 51
00011111
00011111
00011111
00111111
10111111
10111111
10111111
10111111
NAME kitchen 61

TIL 52
11111000
11111100
11111100
11111110
11111110
11111111
11111111
11111111
NAME kitchen 62

TIL 53
00011111
00011111
00011111
00011111
00001111
00001111
00001111
10001111
NAME kitchen 63

TIL 54
10001111
10000111
11000111
11100111
11100111
11100111
11110011
11110011
NAME kitchen 64

TIL 55
11110011
11110011
11110011
11110011
11110011
11110011
11110000
11111000
NAME kitchen 65

TIL 56
11111111
11111111
11111111
11111111
11111111
11111111
00000000
00000000
NAME kitchen 66

TIL 57
11110011
11110001
11111001
11111001
11111111
11111111
00000000
00000000
NAME kitchen 67

TIL 58
11001111
11001111
11001111
11001111
11001111
11001111
00001111
00011111
NAME kitchen 68

TIL 59
11111111
11111001
11111111
11111111
11111111
11111110
11111100
11111100
NAME lishas_bedroom 1

TIL 60
11111111
11111100
11111000
11110000
11000000
10000000
00000000
00000000
NAME lishas_bedroom 28

TIL 61
00000111
00000011
00001111
00000011
00000000
00000000
00000000
00000000
NAME lishas_bedroom 29

TIL 62
11111100
11111111
10111111
11111111
01111111
00001111
00000011
00000000
NAME lishas_bedroom 30

TIL 63
00000000
00000000
11000000
11111000
11111100
11111111
11111111
01111111
NAME lishas_bedroom 31

TIL 64
00010111
00010011
00000011
00001011
00111111
11111111
11111111
11111111
NAME lishas_bedroom 32

TIL 65
11111100
11111000
11110000
11100000
11000000
10000000
00000000
00000000
NAME lishas_bedroom 33

TIL 66
00000000
00000000
00000000
00000000
00000111
00000111
00000011
00000011
NAME lishas_bedroom 34

TIL 67
00000000
00000000
01111111
11111111
11111111
01111111
11111111
11111111
NAME lishas_bedroom 35

TIL 68
00000000
00000000
00000000
11000000
11100000
11110000
11111000
11111000
NAME lishas_bedroom 36

TIL 69
00001111
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 37

TIL 70
00000011
00000011
10000011
10000011
10000001
00000000
00000000
00000000
NAME lishas_bedroom 64

TIL 71
10000000
10000011
11000011
11000111
00011111
01111111
11111111
11111111
NAME lishas_bedroom 65

TIL 72
00000000
00000000
00000000
00000000
00000000
01000000
11010000
11000000
NAME lishas_bedroom 66

TIL 73
00000000
00000000
10000000
10000000
11111001
11111111
11111111
11111111
NAME lishas_bedroom 67

TIL 74
00000000
00000000
00000000
00000000
10000000
10110100
11111110
11111111
NAME lishas_bedroom 68

TIL 75
00000001
00000011
00000011
00000011
00000011
00000011
00000001
00000001
NAME lishas_bedroom 69

TIL 76
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000111
NAME lishas_bedroom 70

TIL 77
00000000
00000100
00001110
00111100
01111000
11100000
11000000
10000000
NAME lishas_bedroom 71

TIL 78
00000000
00000000
00000000
00000000
00000000
01111110
10000001
10111101
NAME lishas_bedroom 72

TIL 79
11111111
11111111
11111111
11111111
00000000
00000000
11111111
11000011
NAME lishas_bedroom 73

TIL 80
01010000
01101000
01010100
01101010
01010100
01101000
01010100
01101010
NAME lishas_bedroom 100

TIL 81
00011110
00110000
00100000
00100000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 101

TIL 82
00011110
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 102

TIL 83
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00001100
NAME lishas_bedroom 103

TIL 84
11111111
11111100
11111100
11001100
10001000
10001000
10001000
10001000
NAME lishas_bedroom 104

TIL 85
10101001
10101001
10101001
10101011
10101010
10101010
10101010
11101010
NAME lishas_bedroom 105

TIL 86
00000000
00000000
00000001
00000001
00000001
00000000
00000000
00000000
NAME lishas_bedroom 106

TIL 87
11111111
10000001
10000001
00000000
11111111
10000001
10000001
11000011
NAME lishas_bedroom 107

TIL 88
00000000
00000000
10000000
10000000
10000000
00000000
00000000
00000000
NAME lishas_bedroom 108

TIL 89
01010100
01101010
01100101
00111010
00011101
00001110
00000111
00000011
NAME lishas_bedroom 109

TIL 90
11111100
00000110
11110011
11111010
11111010
11111010
00000010
11111111
NAME lishas_bedroom 136

TIL 91
10000000
10000000
10000000
00000000
10000000
10000000
10000000
00000000
NAME lishas_bedroom 137

TIL 92
01100010
01100011
01101001
01110101
01101011
01100110
01100100
01111100
NAME lishas_bedroom 138

TIL 93
00011110
00111110
00100110
00101110
00110110
00101110
00111110
00001110
NAME lishas_bedroom 139

TIL 94
11011101
11011111
11001111
11100011
11111000
11111110
11111111
11111111
NAME lishas_bedroom 140

TIL 95
11111111
11111111
11111100
11111101
11111101
11111100
11111111
11111111
NAME lishas_bedroom 141

TIL 96
11111111
11111111
00111110
10111110
10111110
00111100
01111100
11111111
NAME lishas_bedroom 142

TIL 97
11111111
11111111
00011111
11101111
10101111
11110111
00000111
10111111
NAME lishas_bedroom 143

TIL 98
00000000
11111111
11000011
10111101
10111101
11000011
11111111
10000001
NAME lishas_bedroom 144

TIL 99
00000000
10000000
10000000
11000000
01110000
01010000
01010000
01010000
NAME lishas_bedroom 145

TIL a
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME wall
WAL true

TIL b
00000000
00000000
00111100
00111100
00111100
00111100
00000000
00000000
NAME furniture
WAL true

TIL c
00000000
00000000
00111100
00100000
00111000
00100000
00111100
00000000
NAME exit

TIL d
00000000
00100000
01100000
11111111
11111111
01100000
00100000
00000000
NAME stairs

TIL e
00000001
00000011
00000111
00001111
00011111
00111111
01111111
11111111
NAME tl corner

TIL f
10000000
11000000
11100000
11110000
11111000
11111100
11111110
11111111
NAME tr corner

TIL g
11111111
11111110
11111100
11111000
11110000
11100000
11000000
10000000
NAME bl corner

TIL h
11111111
01111111
00111111
00011111
00001111
00000111
00000011
00000001
NAME br corner

TIL i
11111110
11111110
00000110
00000110
00000110
00000110
00000110
00000110

TIL j
11111111
11111111
11000000
11000000
11000000
11000000
11000000
11000000

TIL k
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11000000

TIL l
01001000
01000100
01000010
01000010
01000010
01000010
01000100
01001000

TIL m
11000000
11000000
11000000
11000000
11000000
11000000
11111111
11111111

TIL n
00000110
00000110
00000110
00000110
00000110
00000110
11111110
11111110

TIL o
11111111
11111111
00000000
00000000
00000001
00000111
00001001
00001000

TIL p
00000000
00000000
00000000
00000000
00000000
00000000
11111111
11111111

TIL q
00011000
01101011
01001101
11010101
11010101
11010101
11010101
11010101

TIL r
00001000
00000111
00000000
00000000
00000000
00000000
11111111
11111111

TIL s
11111110
11111110
00000110
00000110
00000110
11000110
00100110
00100110

TIL t
00100110
11000110
00000110
00000110
00000110
00000110
11111110
11111110

TIL u
01010000
01010000
01111111
01010000
01101000
01101000
10100000
10100000

TIL v
00001010
00001010
11111110
00001010
00010110
00010110
00000101
00000101

TIL w
11100111
11100111
11100111
11100111
10100101
11000011
11100111
11111111
>
11111111
11100111
11100111
11100111
11100111
10100101
11000011
11100111
NAME arrow

TIL x
00000000
00000000
00000000
00000000
10000000
01000000
00100000
00010000

TIL y
00010000
00100000
01000000
10000000
00000000
00000000
00000000
00000000

TIL z
00010000
00010000
00010000
00010000
00010000
00010010
00010100
00011000

TIL 1a
00000000
00000000
00000000
00000001
00000000
00000000
00000000
00000000
NAME kitchen 13

TIL 1b
00100001
00100001
10100001
10100001
00100001
00100001
00100001
00100001
NAME kitchen 14

TIL 1c
11011101
01010101
11111111
11111111
00100100
00101100
11111111
11111111
NAME kitchen 15

TIL 1d
00000000
00000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME kitchen 16

TIL 1e
00000011
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME kitchen 17

TIL 1f
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 18

TIL 1g
00001010
00011010
00000010
00000010
00000010
00000010
00000010
00000010
NAME kitchen 19

TIL 1h
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00011111
NAME kitchen 20

TIL 1i
00000000
00000000
00000000
00000000
00000000
00000111
11111111
11111111
NAME kitchen 21

TIL 1j
00100001
00100001
00100001
00100000
00100000
11100000
11100000
11100000
NAME kitchen 22

TIL 1k
00100100
01101100
11111111
00000000
00000000
00000000
00000000
00000000
NAME kitchen 23

TIL 1l
10000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 24

TIL 1m
00000010
00000010
00000010
00000010
00000010
00000010
00001111
00111010
NAME kitchen 25

TIL 1n
00000000
00000000
00000000
00000000
00000000
00111111
11100000
00111111
NAME kitchen 26

TIL 1o
00000000
00000000
00000000
00000000
00000000
11111111
00000000
11111111
NAME kitchen 27

TIL 1p
00000000
00000000
00000000
00000000
00000000
11111000
00001111
11111000
NAME kitchen 28

TIL 1q
00000010
00000010
00000010
00000010
00000010
00011111
11100000
00000000
NAME kitchen 29

TIL 1r
00000000
00000000
00000000
00000111
11111000
00000000
00000000
00000000
NAME kitchen 30

TIL 1s
00000100
00000100
00011111
11100000
00000000
00000000
00000000
00000111
NAME kitchen 31

TIL 1t
00000111
11111100
11110000
01001111
01000001
01011101
11111101
11111111
NAME kitchen 32

TIL 1u
11111111
11111111
11111111
11111111
11111111
00000000
11111000
11110000
NAME kitchen 33

TIL 1v
11111111
11111111
11111111
11111111
11111111
00000000
00000111
00111000
NAME kitchen 34

TIL 1w
11100000
11100000
11100000
11100000
11100000
11100000
00100000
00100000
NAME kitchen 35

TIL 1x
00000000
00011111
00010000
00010000
00010000
00010000
00110000
00100000
NAME kitchen 36

TIL 1y
01010010
11010010
01010010
01010010
01010010
01010010
01010010
01111110
NAME kitchen 37

TIL 1z
00000000
00000000
00000000
00000000
00000000
00000000
00010000
11111100
NAME kitchen 38

TIL 2a
10010100
10000100
10110100
10000100
11110100
10000100
10111100
11111100
NAME kitchen 49

TIL 2b
00001111
00000000
00000000
00001111
00001101
00001110
00001101
00001101
NAME kitchen 50

TIL 2c
11111000
00000000
00000000
11000000
11000000
11000000
01000000
01000000
NAME kitchen 51

TIL 2d
11000000
11000000
11000000
11000000
11100000
11100000
11110000
11110000
NAME kitchen 52

TIL 2e
00000000
00000011
00001111
00000111
00001110
01110000
10000000
00001110
NAME kitchen 53

TIL 2f
00000011
11101110
11110000
11000000
00000000
01110000
01010000
01110000
NAME kitchen 54

TIL 2g
11000000
10000001
10000110
10000000
10000000
10000111
10011000
11100000
NAME kitchen 55

TIL 2h
00000100
10000100
00001100
00110100
11000100
00000100
00000100
00000100
NAME kitchen 56

TIL 2i
00000000
00000000
00000000
00000000
00000110
00000100
00000000
00000000
NAME kitchen 57

TIL 2j
10000000
10000000
10010000
10110000
10000000
10000000
10000000
10000000
NAME kitchen 58

TIL 2k
00100000
00100000
00100000
00100000
00100000
00100000
00111111
01000000
NAME kitchen 59

TIL 2l
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000
NAME kitchen 60

TIL 2m
01000000
01111111
01100001
00100001
00100001
00111111
11100001
00100001
NAME kitchen 61

TIL 2n
00000010
11111110
00000110
00000110
00000110
11111110
00000111
00000110
NAME kitchen 62

TIL 2o
00001111
00001000
00001111
00000000
00000000
00000000
11111111
00000000
NAME kitchen 63

TIL 2p
11000000
01000000
11000000
00000000
00000000
00000000
11111111
00000000
NAME kitchen 64

TIL 2q
11111000
11111000
11111100
11111100
11111110
11111110
11111111
11111111
NAME kitchen 65

TIL 2r
00001010
11001110
01000000
11000001
00001110
00110000
11000000
00000001
NAME kitchen 66

TIL 2s
00000011
00001100
01110000
10000000
00000000
00011100
01100100
10000100
NAME kitchen 67

TIL 2t
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME kitchen 68

TIL 2u
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000010
NAME kitchen 69

TIL 2v
10000000
10000011
10000100
10011000
10100000
11000000
00000000
00000000
NAME kitchen 70

TIL 2w
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 71

TIL 2x
00100001
00100001
00100000
00100000
00100000
00100000
00000000
00000000
NAME kitchen 72

TIL 2y
00000110
00000110
00000100
00000100
00000100
00000100
00000000
00000000
NAME kitchen 73

TIL 2z
11111111
11111111
11111111
01111111
01111111
01111111
01111111
01111111
NAME kitchen 74

TIL 3a
00000111
00000111
00000111
00000111
00000011
00000011
00000011
00000011
NAME kitchen 85

TIL 3b
01100000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 86

TIL 3c
00000011
00000001
00000001
00000001
00000001
00000001
00000000
00000000
NAME kitchen 87

TIL 3d
11111000
11110000
11110011
11110011
11110011
11110011
11110011
11110011
NAME kitchen 1

TIL 3e
00000000
00000000
11111111
11111111
00000000
00000000
00000000
00000000
NAME kitchen 2

TIL 3f
00011111
00001111
11001111
11001111
11001111
11001111
11001111
11001111
NAME kitchen 3

TIL 3g
11110011
11110011
11110011
11110011
11110011
11110011
11110011
11110011
NAME kitchen 4

TIL 3h
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000110
NAME kitchen 5

TIL 3i
00000111
00011000
01110000
11000000
10000000
10000000
00000000
00000000
NAME kitchen 6

TIL 3j
11111111
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 7

TIL 3k
00000000
11110000
00011110
00000011
00000000
00000000
00000000
00000000
NAME kitchen 8

TIL 3l
00000000
00000000
00000000
10000000
11100000
00110000
00011000
00001000
NAME kitchen 9

TIL 3m
11001111
11001111
11001111
11001111
11001111
11001111
11001111
11001111
NAME kitchen 10

TIL 3n
00001100
00011000
00010000
00110000
00100000
01100000
01000000
11000000
NAME kitchen 11

TIL 3o
00001100
00000100
00000110
00000010
00000001
00000001
00000000
00000000
NAME kitchen 12

TIL 3p
00000000
00000000
00000000
00000000
00000000
10000000
11000000
01000000
NAME kitchen 13

TIL 3q
00000000
00000000
00000000
00000011
00000110
00000000
00000000
00000000
NAME kitchen 14

TIL 3r
00000000
00000000
00000000
11110000
00011000
00000000
00000000
00000000
NAME kitchen 15

TIL 3s
00000000
00000000
00000000
00000111
00001100
00000000
00000011
00001110
NAME kitchen 16

TIL 3t
01000000
01000000
01000000
11000000
01000000
01000000
11000000
11000000
NAME kitchen 17

TIL 3u
10000000
10000000
10000000
11111000
10001110
10000011
11000000
01001110
NAME kitchen 18

TIL 3v
00000011
00001110
00000111
00000000
00000000
00000000
00000000
00000000
NAME kitchen 19

TIL 3w
11110000
11100000
11100000
00000000
00000000
00000000
00000000
00000000
NAME kitchen 20

TIL 3x
00000011
00000000
00001000
00000100
00000110
00000011
00000001
00000000
NAME kitchen 21

TIL 3y
11000000
01000000
01100000
00100000
00100000
00100000
10010000
10010000
NAME kitchen 22

TIL 3z
01001000
01101000
00101100
00110100
00010000
00011000
00001100
00000100
NAME kitchen 23

TIL 4a
10000000
11100000
00111000
00001110
00000011
00000000
00000000
00000000
NAME kitchen 34

TIL 4b
00000000
00000000
00000000
00000000
00000000
11000000
01110000
00001111
NAME kitchen 35

TIL 4c
00000000
00000000
00000000
00000001
00000011
00001110
00111000
11110000
NAME kitchen 36

TIL 4d
01000000
01000000
11000000
10000000
00000000
00000000
00000000
00000000
NAME kitchen 37

TIL 4e
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME kitchen 38

TIL 4f
00001111
00001111
00011111
00011111
00011111
00111111
01111111
11111111
NAME kitchen 39

TIL 4g
00001100
10000110
10000011
11000000
11000000
11000000
11100000
11100000
NAME kitchen 40

TIL 4h
00000000
00000000
10000000
11000000
01100000
00111000
00001100
00000110
NAME kitchen 41

TIL 4i
00010000
00010000
00010000
00010000
00111000
00101000
01101000
11001000
NAME kitchen 42

TIL 4j
00000000
00000000
00000011
00011111
01111111
11111111
11111111
11111111
NAME kitchen 43

TIL 4k
00111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME kitchen 44

TIL 4l
11110000
11111000
11111000
11111000
11111100
11111100
11111110
11111110
NAME kitchen 45

TIL 4m
00000011
00000000
00000000
00000000
00000000
00000000
00000001
00000001
NAME kitchen 46

TIL 4n
00000001
10000001
11111111
01111111
01111111
11111111
11111111
11111111
NAME kitchen 47

TIL 4o
10001000
00000100
00000100
00000100
10000101
10000111
11000011
11100011
NAME kitchen 48

TIL 4p
00000000
00000000
00000000
00000000
10000000
11000000
11110000
11111100
NAME kitchen 49

TIL 4q
00000011
00000111
10000100
10001100
11001000
11011000
11110000
11110000
NAME kitchen 50

TIL 4r
11111111
11111111
11111111
01111111
01111111
00111111
00111111
00011111
NAME kitchen 51

TIL 4s
11110011
11110011
11111001
11101101
11100111
11000011
11000001
11000000
NAME kitchen 52

TIL 4t
00000000
10000000
11000000
11110000
11111110
11111111
11111111
11111111
NAME kitchen 53

TIL 4u
00000000
00000000
00000000
00000000
00000000
10000000
11100000
11111000
NAME kitchen 54

TIL 4v
11100000
11100000
11110000
11111000
11111000
11111100
11111100
11111100
NAME kitchen 55

TIL 4w
00001111
00001111
00001111
00011111
00011111
00011111
00011111
00011111
NAME kitchen 56

TIL 4x
11100000
11100000
11100000
11110000
11110000
11110000
11111000
11111000
NAME kitchen 57

TIL 4y
01111111
01111111
00111111
00111111
00111111
00111111
00111111
00011111
NAME kitchen 58

TIL 4z
11111100
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME kitchen 59

TIL 5a
11111111
11111111
00000001
00000000
00000000
00000000
00000000
01100000
NAME lishas_bedroom 2

TIL 5b
11011111
11111111
11111111
00111111
01110001
01111100
01111111
11111111
NAME lishas_bedroom 3

TIL 5c
00000000
10000000
11110000
11110110
11111111
01111111
00011111
11011111
NAME lishas_bedroom 4

TIL 5d
11111111
11111111
11111111
11111110
11111111
11111111
11111111
11111111
NAME lishas_bedroom 5

TIL 5e
11111000
11110000
11100000
11000000
11000000
10000000
10000000
00000000
NAME lishas_bedroom 6

TIL 5f
01100011
00000101
00000101
00000101
00000001
00000011
00000111
00000111
NAME lishas_bedroom 7

TIL 5g
11111111
11111111
11111110
11111110
11111110
11111100
10111100
10111100
NAME lishas_bedroom 8

TIL 5h
00001111
00001111
00011111
00111111
01111111
00111111
01111111
11111111
NAME lishas_bedroom 9

TIL 5i
11111000
11111000
11111000
11111000
11110000
11110000
11110000
11100000
NAME lishas_bedroom 10

TIL 5j
00000010
00000011
00000001
00001111
00001111
00001111
00001111
00011111
NAME lishas_bedroom 11

TIL 5k
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111101
NAME lishas_bedroom 12

TIL 5l
11111111
11111111
11111111
11111111
11111111
11110111
11100111
11000111
NAME lishas_bedroom 13

TIL 5m
11110000
11101111
11111111
11111101
11111111
11111111
11111100
11111111
NAME lishas_bedroom 14

TIL 5n
00111111
01111111
00111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 15

TIL 5o
11111111
11100010
11100000
11000000
11100000
11000000
10000000
10000000
NAME lishas_bedroom 16

TIL 5p
11000111
00001111
00011111
00011111
00000111
00000111
00001111
00011111
NAME lishas_bedroom 17

TIL 5q
11111111
11111111
11111111
11111110
11111100
11110000
11100000
10000000
NAME lishas_bedroom 18

TIL 5r
11111111
11000001
10000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 19

TIL 5s
11111111
11111111
00111111
00000111
00000000
00000000
00000000
00000000
NAME lishas_bedroom 20

TIL 5t
11111111
11111111
11111111
01111100
00111100
00000000
00000000
00000000
NAME lishas_bedroom 21

TIL 5u
11111111
11100001
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 22

TIL 5v
11111111
11111111
00111111
00011111
00011111
00001111
00001111
00000111
NAME lishas_bedroom 23

TIL 5w
11111111
01111111
01111110
11111100
11111000
11111100
11111100
11111100
NAME lishas_bedroom 24

TIL 5x
10000000
10000000
11000000
10000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 25

TIL 5y
00011111
00001111
00000111
00000011
00001101
00011101
00011111
00000111
NAME lishas_bedroom 26

TIL 5z
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME lishas_bedroom 27

TIL 6a
11111111
11111111
01111111
00011111
00000111
00000111
00000111
00000111
NAME lishas_bedroom 38

TIL 6b
11111110
11111100
11111000
11110000
11100000
11000000
11000000
10000000
NAME lishas_bedroom 39

TIL 6c
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 40

TIL 6d
11111111
11111111
11111111
01111111
00111111
00001111
00000011
00000001
NAME lishas_bedroom 41

TIL 6e
11111100
11111000
11111000
11111000
11110000
11110000
11111100
11011100
NAME lishas_bedroom 42

TIL 6f
00000001
00000101
00001001
00001001
00111011
00111111
01111111
11111111
NAME lishas_bedroom 43

TIL 6g
11111111
11111110
11111100
11111000
11110000
11100000
11100000
11100000
NAME lishas_bedroom 44

TIL 6h
00000101
00000000
00000001
00000001
00000001
00000001
00000001
00000000
NAME lishas_bedroom 45

TIL 6i
11111111
11111111
11111111
11111111
11111110
11111100
11111100
11111000
NAME lishas_bedroom 46

TIL 6j
11000000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 47

TIL 6k
01111111
01111111
00111111
00111111
00011111
00001111
00000111
00000111
NAME lishas_bedroom 48

TIL 6l
11111111
11111111
11111111
11111111
11111111
11111110
11111100
11111000
NAME lishas_bedroom 49

TIL 6m
11110000
11100000
11000000
10000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 50

TIL 6n
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000010
NAME lishas_bedroom 51

TIL 6o
00000000
00000000
00000100
00011000
00011100
00111100
01111111
01110111
NAME lishas_bedroom 52

TIL 6p
00000000
00001000
10001000
11000000
11100000
11100000
11100000
10100000
NAME lishas_bedroom 53

TIL 6q
00000111
00000011
00000011
00000011
00000001
00000001
00000011
00000011
NAME lishas_bedroom 54

TIL 6r
11110000
11100000
11100000
11000000
11000000
10000000
00000000
00000000
NAME lishas_bedroom 55

TIL 6s
00000000
00000001
00000011
00000011
00000001
00000001
00000001
00000000
NAME lishas_bedroom 56

TIL 6t
01101111
01101011
11011110
11011111
11111111
11111111
11111111
00110111
NAME lishas_bedroom 57

TIL 6u
10000000
10000000
00000000
00100000
11110000
11110000
11110000
11110000
NAME lishas_bedroom 58

TIL 6v
00000001
00000001
00000011
00000001
00000001
00000001
00000001
00001001
NAME lishas_bedroom 59

TIL 6w
00000111
00000111
00100000
00000000
00000000
00001100
00000111
00000111
NAME lishas_bedroom 60

TIL 6x
11000000
11000000
11000000
00000000
00000000
00000000
10000001
00000001
NAME lishas_bedroom 61

TIL 6y
00001001
00001111
00001111
00001111
00011111
00111111
11111111
11111111
NAME lishas_bedroom 62

TIL 6z
00000111
00001111
00001111
00001111
00011111
00011111
00010010
00000000
NAME lishas_bedroom 63

TIL 7a
11111111
11111111
11111111
11111111
00000000
00000000
11111111
11111111
NAME lishas_bedroom 74

TIL 7b
11111111
11111111
11111111
11111111
00000000
00000000
11111111
10000000
NAME lishas_bedroom 75

TIL 7c
11111111
11111111
11111111
11111111
00000000
00000000
11111111
00000111
NAME lishas_bedroom 76

TIL 7d
11111111
11111111
11111111
11111111
00000000
00000000
11111111
11100011
NAME lishas_bedroom 77

TIL 7e
00000000
00000000
00000000
00000001
00000011
00001100
00001000
00010000
NAME lishas_bedroom 78

TIL 7f
00000000
00000000
01111111
11000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 79

TIL 7g
00000000
00000000
11111111
00000001
00000000
00000000
00000000
00000000
NAME lishas_bedroom 80

TIL 7h
00000000
00000000
00000000
11000000
01100000
00110000
00010000
00010000
NAME lishas_bedroom 81

TIL 7i
11111111
11111111
11111111
11111111
11111111
11111111
11101010
10101010
NAME lishas_bedroom 82

TIL 7j
00001110
00111100
01111000
11100000
11000000
10000000
00000000
00000000
NAME lishas_bedroom 83

TIL 7k
10111101
10111101
10000001
01111110
01000010
00100100
00011000
00000000
NAME lishas_bedroom 84

TIL 7l
10000010
10000010
10000010
10000011
10000000
10000011
10000010
10000010
NAME lishas_bedroom 85

TIL 7m
11111110
11111110
01111100
10000011
11111110
01111101
01010100
10101010
NAME lishas_bedroom 86

TIL 7n
10000000
10000000
10000000
10000000
00000000
11110000
10010000
10011100
NAME lishas_bedroom 87

TIL 7o
00001100
00001011
00001011
00001011
00001011
00001000
00000111
00000001
NAME lishas_bedroom 88

TIL 7p
00111111
11011111
11011011
11011111
11010101
00010111
11100011
10001001
NAME lishas_bedroom 89

TIL 7q
00110000
00101000
00110000
00101000
00110000
01101000
01010000
01100000
NAME lishas_bedroom 90

TIL 7r
00000000
00000000
00000001
00000000
00100000
00010000
00000000
00000011
NAME lishas_bedroom 91

TIL 7s
00000000
00000001
00000010
10000000
00000000
00000000
00000000
11110000
NAME lishas_bedroom 92

TIL 7t
00011000
00001000
00001000
00001000
00001000
00001000
00001100
00000100
NAME lishas_bedroom 93

TIL 7u
10101011
10101001
10101001
10101010
10101110
10101000
10101000
10101111
NAME lishas_bedroom 94

TIL 7v
10000010
10000010
10000011
11000011
11111111
01000000
00100000
00000000
NAME lishas_bedroom 95

TIL 7w
01000100
10111010
01111101
11111111
11111111
00000000
00000000
00000000
NAME lishas_bedroom 96

TIL 7x
10010100
10010100
10011100
10000000
11111111
00000000
10000001
10000001
NAME lishas_bedroom 97

TIL 7y
00000011
00000000
00000000
00000000
11111111
00000000
00000000
00000000
NAME lishas_bedroom 98

TIL 7z
11001011
00000001
00001001
00000011
11111111
00000010
00000100
00000000
NAME lishas_bedroom 99

TIL 8a
00000000
10000000
01010000
10001000
00100100
10001010
01010000
10001010
NAME lishas_bedroom 110

TIL 8b
00000000
00000000
00000000
00000000
00000000
10100000
00010100
10001010
NAME lishas_bedroom 111

TIL 8c
00010100
00001100
00010100
00001000
00011000
00111000
01010000
00110000
NAME lishas_bedroom 112

TIL 8d
10001000
10001100
10001100
10001100
10001100
10001100
10001100
10001000
NAME lishas_bedroom 113

TIL 8e
11111111
11111111
11111111
11111111
11101111
11100111
11100011
11100001
NAME lishas_bedroom 114

TIL 8f
11101010
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 115

TIL 8g
01000010
01111110
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 116

TIL 8h
11100001
00011100
00000111
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 117

TIL 8i
01000000
10001010
11111111
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 118

TIL 8j
00100000
11100000
10000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 119

TIL 8k
10001000
10001000
10001000
10001000
11001100
11111100
11111100
11111111
NAME lishas_bedroom 120

TIL 8l
11100000
11100000
11100000
11100001
11100000
11100010
11100001
11100000
NAME lishas_bedroom 121

TIL 8m
11111111
01111111
00111111
00011111
10001111
00000111
00000011
10000001
NAME lishas_bedroom 122

TIL 8n
00000000
00000000
00000000
00000000
00100000
01000000
01111111
01111111
NAME lishas_bedroom 123

TIL 8o
00000000
00000000
00000000
00000000
00000100
00000010
11111110
11111110
NAME lishas_bedroom 124

TIL 8p
11111111
11111110
11111000
11100011
11001111
11011111
11011001
11011011
NAME lishas_bedroom 125

TIL 8q
11100000
11100000
11100000
11100000
11100000
11100000
11100000
11100000
NAME lishas_bedroom 126

TIL 8r
00000001
00000001
00000011
00000111
00001111
00011111
00111111
01111111
NAME lishas_bedroom 127

TIL 8s
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00010000
NAME lishas_bedroom 128

TIL 8t
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME lishas_bedroom 129

TIL 8u
01101100
01110100
01101100
01100100
01100100
01100100
01100100
01100100
NAME lishas_bedroom 130

TIL 8v
01111110
00011110
00001110
00001110
00000110
00000110
00000110
00001110
NAME lishas_bedroom 131

TIL 8w
11011011
11011011
11011001
11011101
11011101
11011101
11011101
11011101
NAME lishas_bedroom 132

TIL 8x
11100000
11100001
11100011
11100111
11101111
11111111
11111111
11111111
NAME lishas_bedroom 133

TIL 8y
00010011
00010110
00011100
00000101
00010101
00010101
00010100
00001111
NAME lishas_bedroom 134

TIL 8z
11111111
00000000
11111111
11111111
11111111
11111111
00000000
11111111
NAME lishas_bedroom 135

TIL 9a
01111000
01101000
01111000
01110000
01110000
01110000
01110000
01110000
NAME lishas_bedroom 146

TIL 9b
00000110
00000110
00000110
00000110
00000111
00000110
00000111
00001111
NAME lishas_bedroom 147

TIL 9c
11111111
11111100
11110000
11100000
10100000
00100000
00100000
00100000
NAME lishas_bedroom 148

TIL 9d
10000110
10110110
01110110
01110110
01000111
01110111
01010011
01111011
NAME lishas_bedroom 149

TIL 9e
00111111
11010000
10010111
00110110
01110110
11110110
11100111
11101111
NAME lishas_bedroom 150

TIL 9f
11111111
00000011
11111011
00111011
00111011
01111011
11111011
11001011
NAME lishas_bedroom 151

TIL 9g
10000001
10001111
10011001
10010101
10010101
10010101
10011001
10001111
NAME lishas_bedroom 152

TIL 9h
01010000
01010000
01010000
01010000
01010000
01010000
01010000
01010000
NAME lishas_bedroom 153

TIL 9i
01100000
01100000
01100000
01110000
01101111
01100011
01101000
01110100
NAME lishas_bedroom 154

TIL 9j
00000000
00000000
00000011
00001110
11111000
00011000
01000010
10100101
NAME lishas_bedroom 155

TIL 9k
00000000
00000000
11111111
00000000
11000110
11000110
00010000
00101001
NAME lishas_bedroom 156

TIL 9l
00011111
11111111
11001111
00000111
00110111
00110111
10000111
01001111
NAME lishas_bedroom 157

TIL 9m
00101011
10000001
11101111
11111111
11110000
11110010
11110110
11110110
NAME lishas_bedroom 158

TIL 9n
11101111
11001111
11100000
11111111
00000000
11111101
11111101
11111101
NAME lishas_bedroom 159

TIL 9o
11001001
11001101
00000001
11011111
01011111
10111111
10111111
10111111
NAME lishas_bedroom 160

TIL 9p
11100001
10010001
10111011
11110101
10101001
11010001
10011011
10011111
NAME lishas_bedroom 161

TIL 9q
01101000
01100000
01111111
01110000
01110000
01110000
01110000
01110000
NAME lishas_bedroom 162

TIL 9r
01000010
00000000
11111111
00000011
00000011
00000001
00000001
00000001
NAME lishas_bedroom 163

TIL 9s
00010000
00000000
11111111
11000000
10000000
10000000
10000000
10000000
NAME lishas_bedroom 164

TIL 9t
10000111
00000111
11111110
00001111
00001110
00001110
00001110
00001110
NAME lishas_bedroom 165

TIL 9u
00100000
00100000
00100000
10100000
11100000
11110000
11111100
11111111
NAME lishas_bedroom 166

TIL 9v
11101110
11101111
11001100
11011001
11010011
11010111
10010110
10111100
NAME lishas_bedroom 167

TIL 9w
01111001
01111011
01110011
01110101
01110100
01110110
00000111
11110001
NAME lishas_bedroom 168

TIL 9x
10111111
10111111
10111111
11011111
11011111
01011111
00101111
10101111
NAME lishas_bedroom 169

TIL 9y
10100011
10010101
10001001
10000001
10000001
10000001
11111111
00000000
NAME lishas_bedroom 170

TIL 9z
01010000
01010000
01100000
11000000
10000000
10000000
00000000
00000000
NAME lishas_bedroom 171

TIL a0
01111111
01111111
01000000
01111111
01000000
01111111
00000000
00000000
NAME lishas_bedroom 172

TIL a1
11111111
11111111
00000000
11111111
00000000
11111111
00000000
00000000
NAME lishas_bedroom 173

TIL a2
11111110
11111110
00000010
11111110
00000010
11111110
00000000
00000000
NAME lishas_bedroom 174

TIL a3
10111101
10111101
00111100
00001111
11100000
11111111
11111111
11111111
NAME lishas_bedroom 175

TIL a4
11111101
11111001
11110011
00000111
00000000
11011111
11011111
11111111
NAME lishas_bedroom 176

TIL a5
10100111
11110111
11110011
11111011
00000011
11111111
11111111
11111111
NAME lishas_bedroom 177

TIL a6
01000010
01111110
01000010
01111110
01000010
01111110
01000010
01111110
NAME lishas_bedroom 1

TIL a7
01000010
01111110
01000010
01111110
01000010
00000000
11111111
11111111
NAME lishas_bedroom 2

TIL a8
11111111
01111110
01111010
00101010
00101010
01111010
01111110
11111111
NAME lishas_bedroom 3

TIL a9
11111111
11111101
11110101
01010101
01010101
11110101
11111101
11111111
NAME lishas_bedroom 4

TIL aa
00000000
00000000
00000000
00000000
00000000
00000000
00011111
00000000
NAME lishas_bedroom 5

TIL ab
00000000
00000000
00000000
00000000
00000000
00000000
11111110
00000000
NAME lishas_bedroom 6

TIL ac
10000001
00000000
11000000
00000000
10000001
11111111
00000000
00000011
NAME lishas_bedroom 7

TIL ad
00000101
00010101
00000101
00000101
00000101
11111101
00000101
00010101
NAME lishas_bedroom 8

TIL ae
00010000
01110000
01010000
00010000
11010000
00010000
01010000
01110000
NAME lishas_bedroom 9

TIL af
00000000
00000011
00111110
00100010
00100010
00100010
00100011
00100010
NAME lishas_bedroom 10

TIL ag
00000000
11111110
00000010
00000010
00000010
00000010
01111110
00000010
NAME lishas_bedroom 11

TIL ah
00000000
01111110
01000011
01000010
01000010
01000010
01000010
01000010
NAME lishas_bedroom 12

TIL ai
00000000
01111111
01000000
01111111
00100000
00000000
00000000
00000000
NAME lishas_bedroom 13

TIL aj
00000000
11100000
00100000
11100000
01000000
00000000
00000000
00000000
NAME lishas_bedroom 14

TIL ak
00000000
01001110
00111010
00101010
00101010
00111010
01001110
00000000
NAME lishas_bedroom 15

TIL al
10011100
10010100
10011100
10000011
10000000
10001111
10001000
10001011
NAME lishas_bedroom 16

TIL am
00000101
00000101
00000001
11111101
00000101
00010101
00000101
00000101
NAME lishas_bedroom 17

TIL an
00010000
00010000
00010000
10110000
10110000
00010000
00010000
10110000
NAME lishas_bedroom 18

TIL ao
00100010
00111110
00000010
00000010
00000011
00000000
00000000
00000000
NAME lishas_bedroom 19

TIL ap
00000010
00000010
00000010
00000010
11111110
00000000
00000111
00000100
NAME lishas_bedroom 20

TIL aq
01000010
01000010
01000010
01111110
01000010
01000011
01111110
00000000
NAME lishas_bedroom 21

TIL ar
00000000
00100010
01111111
01000001
01000001
01000001
01111111
00000000
NAME lishas_bedroom 22

TIL as
00000000
00000010
00000010
00000010
00000010
00000010
00000010
00000000
NAME lishas_bedroom 23

TIL at
00001010
10001011
10001010
10001011
10001000
10001111
10000000
00000000
NAME lishas_bedroom 24

TIL au
00000101
11111101
00000101
00010101
00000101
00000101
00000101
11111101
NAME lishas_bedroom 25

TIL av
10110000
00010000
00010000
11010000
01010000
11010000
00010000
11010000
NAME lishas_bedroom 26

TIL aw
00000100
00000100
00000100
00000100
00000100
00000100
00000111
00000000
NAME lishas_bedroom 27

TIL ax
01111110
01000010
01000010
01000010
01000110
01000010
01000010
01111110
NAME lishas_bedroom 28

TIL ay
11111111
11111111
11111111
11111011
11010110
11111101
11101100
11111111
NAME lishas_bedroom 29

TIL az
11111111
11111111
11111111
01011011
11101010
10111111
11101101
11111111
NAME lishas_bedroom 30

TIL b0
00000011
00000111
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 31

TIL b1
11111110
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 32

TIL b2
00000000
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME lishas_bedroom 33

TIL b3
11111111
00000000
01111111
01000000
01000000
01000000
01111111
01000000
NAME lishas_bedroom 34

TIL b4
11111111
00001111
11101111
00101111
00101111
00101111
11101111
00101111
NAME lishas_bedroom 35

TIL b5
00000000
00000000
00000000
00111110
00100010
00100010
00100010
00100010
NAME lishas_bedroom 36

TIL b6
00000000
00000000
11111111
10000000
10000000
10000000
10000000
10000000
NAME lishas_bedroom 37

TIL b7
00000001
00000001
11111101
00000101
00000101
00000101
00000100
00000100
NAME lishas_bedroom 38

TIL b8
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME lishas_bedroom 39

TIL b9
00100000
00101111
00101001
00101111
00100000
00100000
00100000
00100000
NAME lishas_bedroom 40

TIL ba
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000010
NAME lishas_bedroom 41

TIL bb
00000000
00000001
00000101
00010101
00010101
00010101
11110101
00110101
NAME lishas_bedroom 42

TIL bc
01000000
01000000
01111111
00100000
00000000
00111111
01100000
01000000
NAME lishas_bedroom 43

TIL bd
00100000
00100000
11100000
01000000
00000000
10000000
11100000
00100000
NAME lishas_bedroom 44

TIL be
00000111
00000100
00000100
00111100
00101100
00101100
00101100
00111100
NAME lishas_bedroom 45

TIL bf
11110101
00010101
00010101
00010101
00010101
00010101
00010101
00010101
NAME lishas_bedroom 46

TIL bg
00000000
01111111
00000000
00111110
00000000
00000000
00000000
00000000
NAME lishas_bedroom 47

TIL bh
00000000
01111111
01000000
01000000
01000000
01111111
01000000
01000000
NAME lishas_bedroom 48

TIL bi
01001100
01000011
01000000
01000000
01000000
01100000
00100000
00100111
NAME lishas_bedroom 49

TIL bj
00100000
00100100
00101000
01101111
01000000
01000000
01000000
11000000
NAME lishas_bedroom 50

TIL bk
00000000
00000010
00000001
11111111
01000101
01000101
01111101
00000001
NAME lishas_bedroom 51

TIL bl
00000000
00000000
00100100
01000010
01111110
01000010
01000010
01000010
NAME lishas_bedroom 52

TIL bm
00000000
00000000
00000000
11100000
10100000
10111111
10100000
10010011
NAME lishas_bedroom 53

TIL bn
00000000
00000000
00000000
00000011
00000010
11111110
00000010
11100100
NAME lishas_bedroom 54

TIL bo
00000100
00000100
00000100
10000100
10111100
10101100
10101100
10101100
NAME lishas_bedroom 55

TIL bp
00010101
00010101
00010101
00010101
00010101
00010101
00000101
00000011
NAME lishas_bedroom 56

TIL bq
00000000
00000000
00000000
00000000
00000000
00001111
00001000
00001000
NAME lishas_bedroom 57

TIL br
00000000
00000000
00000000
00000000
00000000
11111111
00000001
00000001
NAME lishas_bedroom 58

TIL bs
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01111111
NAME lishas_bedroom 59

TIL bt
00111100
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 60

TIL bu
00001111
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 61

TIL bv
11111111
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 62

TIL bw
00000000
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 63

TIL bx
01111110
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 64

TIL by
10000000
11111111
11111111
11111100
11111011
11111011
11111011
11111011
NAME lishas_bedroom 65

TIL bz
00000000
11111111
11111111
00111111
11011111
11011111
11011111
11011111
NAME lishas_bedroom 66

TIL c0
10111100
10000100
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 67

TIL c1
00000010
00000010
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 68

TIL c2
00001000
00001000
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 69

TIL c3
00000001
00000001
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 70

TIL c4
11111011
11111100
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 71

TIL c5
11011111
00111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 72

TIL c6
11111111
11111111
11111111
11111111
11111111
11100011
11101000
11101100
NAME lishas_bedroom 1

TIL c7
11111111
11100000
11101110
11101011
11100100
11110000
11111111
11111111
NAME lishas_bedroom 2

TIL c8
11111111
00011111
11011111
01011000
10011011
00111000
11111111
11111111
NAME lishas_bedroom 3

TIL c9
11111111
11111110
11111110
01111111
01111111
01111111
11111111
11111111
NAME lishas_bedroom 4

TIL ca
11111111
00000000
01111111
00110101
10011011
11000000
11111111
11111111
NAME lishas_bedroom 5

TIL cb
11111111
00001111
11001111
10011111
00111111
01111111
11111111
11111111
NAME lishas_bedroom 6

TIL cc
11100101
11110001
11111011
11111111
01111111
10111111
11011111
11001111
NAME lishas_bedroom 7

TIL cd
00000000
01111111
01000000
01000000
01000000
01000000
01000000
01000000
NAME lishas_bedroom 8

TIL ce
00000000
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 9

TIL cf
00000000
11110000
00011000
00010100
00010000
00010000
00010000
00010000
NAME lishas_bedroom 10

TIL cg
10100000
10111001
10111001
10000000
11111111
01011001
00111111
00000000
NAME lishas_bedroom 11

TIL ch
00000010
00010010
11010010
00000010
11111110
00100100
11111000
00000000
NAME lishas_bedroom 12

TIL ci
00111100
01000010
01011010
01011010
01000010
00111100
00100100
00011000
NAME lishas_bedroom 13

TIL cj
00000000
00000011
00000101
00000101
00000101
00000101
00000101
00000101
NAME lishas_bedroom 14

TIL ck
11000001
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME lishas_bedroom 15

TIL cl
11010111
11011011
11011100
11011100
11011100
11011100
11011100
11011100
NAME lishas_bedroom 16

TIL cm
00000000
00000000
00000000
00000000
00000000
00111100
01000010
01000010
NAME lishas_bedroom 17

TIL cn
00000101
00000101
00000101
00000101
00000101
00000101
00000101
00000011
NAME lishas_bedroom 18

TIL co
11011100
11011100
11011011
11010111
11001111
11011111
10111111
01111111
NAME lishas_bedroom 19

TIL cp
01000000
01111111
01001000
01010101
01100010
01010101
01111111
01100000
NAME lishas_bedroom 20

TIL cq
00000000
11111111
00100000
01010101
10001010
01010101
11111111
01110000
NAME lishas_bedroom 21

TIL cr
00010000
11110000
10010000
01010000
00110000
01010000
11110000
00110000
NAME lishas_bedroom 22

TIL cs
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000010
NAME lishas_bedroom 23

TIL ct
00000000
00000000
00000000
00010000
00100000
01111111
01000000
01000100
NAME lishas_bedroom 24

TIL cu
01000010
00111100
01000010
01000010
01111110
11111111
10000001
11111111
NAME lishas_bedroom 25

TIL cv
00000000
00000000
00000000
00001000
00000100
11111110
00000010
00110010
NAME lishas_bedroom 26

TIL cw
11000001
01111110
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas_bedroom 27

TIL cx
11111111
11100011
11001011
11011011
11011011
10011011
10000011
11001111
NAME lishas_bedroom 28

TIL cy
01000000
01000000
01000000
01000000
01000000
01100000
01111111
00000000
NAME lishas_bedroom 29

TIL cz
00100000
00100000
00100000
00100000
00100000
01110000
11111111
00000000
NAME lishas_bedroom 30

TIL d0
00010000
00010000
00010000
00010000
00010100
00111000
11110000
00000000
NAME lishas_bedroom 31

TIL d1
11111111
10000101
10000111
10110001
11011001
11001001
11111111
00000000
NAME lishas_bedroom 32

TIL d2
01001011
01001010
01000100
01000000
01000001
01000001
01111111
00000000
NAME lishas_bedroom 33

TIL d3
00001000
00111110
01000001
10111110
01111111
11111111
11111111
00000000
NAME lishas_bedroom 34

TIL d4
00110010
00000010
00000010
10000010
01000010
11000010
11111110
00000000
NAME lishas_bedroom 35

TIL d5
11111111
11111111
11000001
11011101
11011101
11001101
11000001
11111111
NAME lishas_bedroom 36

TIL d6
11111111
11111111
11100011
11101011
11101101
11011101
10011100
10100110
NAME lishas_bedroom 37

TIL d7
11111111
11111111
11100001
11101101
11100001
11111111
11111111
11111111
NAME lishas_bedroom 38

TIL d8
11111111
11111111
10001110
01101100
00001101
11111100
11111000
00011010
NAME lishas_bedroom 39

TIL d9
11111111
11111111
00011111
11001111
11101111
10000111
10010111
11001011
NAME lishas_bedroom 40

TIL da
11111111
10000000
01111110
01111101
01110001
01100101
01101001
01101011
NAME lishas_bedroom 41

TIL db
11111111
00000111
00111011
10011011
11011011
11011011
11011011
11011011
NAME lishas_bedroom 42

TIL dc
11111111
11000011
10011001
10111101
10101110
00111110
01111100
00000001
NAME lishas_bedroom 43

TIL dd
01100110
00100111
10000000
11111111
11111111
11000001
11011100
10010110
NAME lishas_bedroom 44

TIL de
01100111
01101011
01100011
11111111
11111111
11111111
11110001
01110101
NAME lishas_bedroom 45

TIL df
01011010
00011000
11111111
11000001
11011000
11011010
11000110
11011111
NAME lishas_bedroom 46

TIL dg
11101011
00000011
11111111
11111111
11111111
11111111
01111111
01111111
NAME lishas_bedroom 47

TIL dh
01101001
01001100
01011110
01011100
01000001
01111111
01111111
01001100
NAME lishas_bedroom 48

TIL di
11011011
00011011
11111011
11111011
11111011
11111011
11111011
11001011
NAME lishas_bedroom 49

TIL dj
11111111
11111111
11110001
11110101
11110001
11111111
11111111
11111111
NAME lishas_bedroom 50

TIL dk
10110111
10110111
00110111
01100111
01100011
01111111
01111110
00000000
NAME lishas_bedroom 51

TIL dl
01110101
01110001
10111111
10111111
10111111
10111111
00111111
11111111
NAME lishas_bedroom 52

TIL dm
11011111
11011000
10011011
10111011
10111001
10000000
11111111
11111111
NAME lishas_bedroom 53

TIL dn
00111111
10111111
10111111
10111111
00111111
11111111
11111111
11111111
NAME lishas_bedroom 54

TIL do
01100000
01111111
10000000
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 55

TIL dp
01101011
11001111
00000111
11111111
11111111
11111111
11111111
11111111
NAME lishas_bedroom 56

TIL dq
11111111
11111111
11111111
11111111
11111111
11110001
11110100
11110110
NAME caitlyns_bedroom 1

TIL dr
11111000
11111011
11111011
11111011
11111000
11111100
00111111
01111111
NAME caitlyns_bedroom 2

TIL ds
00000001
11011101
11011101
01101101
10010001
00000011
11111111
11111111
NAME caitlyns_bedroom 3

TIL dt
11111111
11111111
11111111
10000011
10111011
10000011
11111111
11111111
NAME caitlyns_bedroom 4

TIL du
11111000
11111000
11111000
11111100
11111111
11111111
11111111
11111111
NAME caitlyns_bedroom 5

TIL dv
00000000
11111111
11111111
01101101
00110011
10000000
11111111
11111111
NAME caitlyns_bedroom 6

TIL dw
00000111
11000111
11000111
10001111
00111111
01111111
11111111
11111111
NAME caitlyns_bedroom 7

TIL dx
11110010
11110010
11111000
11111101
11111111
11111111
01111111
10111111
NAME caitlyns_bedroom 8

TIL dy
11000000
11000000
11011111
11010000
11010000
11010000
11010000
11010000
NAME caitlyns_bedroom 9

TIL dz
00000000
00000000
11111111
00000000
00000000
00000000
00000000
00000000
NAME caitlyns_bedroom 10

TIL e0
00000011
00000011
11000011
11100011
11010011
11010011
11000011
11000000
NAME caitlyns_bedroom 11

TIL e1
01000000
01000000
01110001
01110001
00000000
00000000
11111111
10110001
NAME caitlyns_bedroom 12

TIL e2
00000001
00000001
00001001
11001001
00000001
00000001
11111111
00110010
NAME caitlyns_bedroom 13

TIL e3
10000000
10001111
10010000
10010111
10010111
10010111
10010000
00001111
NAME caitlyns_bedroom 14

TIL e4
00000000
10000000
01000000
01000000
01000000
01000000
01000000
10000000
NAME caitlyns_bedroom 15

TIL e5
00000001
00000001
00001110
00010110
00010110
00010110
00010110
00010110
NAME caitlyns_bedroom 16

TIL e6
11001111
11001111
11000111
11001011
11001101
11001110
11001110
11001110
NAME caitlyns_bedroom 17

TIL e7
11010000
11010000
11010000
11010000
11010000
00010000
00010000
00010000
NAME caitlyns_bedroom 18

TIL e8
01111111
01111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME caitlyns_bedroom 19

TIL e9
11111100
11111100
00000000
00000000
00000000
00000000
00000000
00000000
NAME caitlyns_bedroom 20

TIL ea
00001000
00001000
00000111
00000000
00000000
00000000
00000000
00000000
NAME caitlyns_bedroom 21

TIL eb
10000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME caitlyns_bedroom 22

TIL ec
00010110
00010110
00010110
00010110
00010110
00010110
00010110
00010110
NAME caitlyns_bedroom 23

TIL ed
11001110
11001110
11001110
11001110
11001110
11001110
11001101
11001101
NAME caitlyns_bedroom 24

TIL ee
00010000
00010000
00010000
00010000
00010000
00011111
11010011
11010011
NAME caitlyns_bedroom 25

TIL ef
00000000
00000000
00000000
00000000
00000000
11111111
00000010
00000010
NAME caitlyns_bedroom 26

TIL eg
00000000
00000000
00000000
00000000
00000000
11111111
00000100
00000100
NAME caitlyns_bedroom 27

TIL eh
00000000
00001111
00010000
00010000
00010000
00001111
00010000
00010000
NAME caitlyns_bedroom 28

TIL ei
00000000
10000000
01000000
01000000
01000000
10000000
01000000
01000000
NAME caitlyns_bedroom 29

TIL ej
00010110
00010110
00001110
00000001
00000001
00000000
00000000
00000000
NAME caitlyns_bedroom 30

TIL ek
10000000
10000000
10000000
10000000
10000001
11111110
00000000
00000000
NAME caitlyns_bedroom 31

TIL el
11001011
11000111
11001111
10111111
01111111
11111111
11111111
11110001
NAME caitlyns_bedroom 32

TIL em
11010100
11011000
11010100
11011111
11011000
11010000
11010000
11010000
NAME caitlyns_bedroom 33

TIL en
10101101
01010000
10101101
11111111
00001111
00000110
00000110
00000110
NAME caitlyns_bedroom 34

TIL eo
01001010
10110001
01001010
11111111
00000001
00000000
00000000
00000000
NAME caitlyns_bedroom 35

TIL ep
11000000
11000000
11000000
11000000
11000000
11000011
11000011
11000011
NAME caitlyns_bedroom 36

TIL eq
00000000
00000000
00000000
00000000
10000010
11111111
11111111
00001101
NAME caitlyns_bedroom 37

TIL er
00001000
00110000
01111111
01000000
01000010
01000101
01000101
01000101
NAME caitlyns_bedroom 38

TIL es
00010000
00011111
11111111
00100000
00111111
11000001
11000001
10001111
NAME caitlyns_bedroom 39

TIL et
01000000
11000000
11111111
00100000
11100011
00000011
00000011
11000000
NAME caitlyns_bedroom 40

TIL eu
10000000
01100000
11110000
00010000
00010000
00010000
00010000
00010000
NAME caitlyns_bedroom 41

TIL ev
11000101
11000101
11001101
11001101
10001101
10001101
10000001
11000111
NAME caitlyns_bedroom 42

TIL ew
11010000
11010000
11010000
11010000
11011000
11011000
11011111
11000000
NAME caitlyns_bedroom 43

TIL ex
00000110
00000110
00000110
00000110
00001111
00001111
11111111
00000000
NAME caitlyns_bedroom 44

TIL ey
00000000
00000000
00000000
00000000
00000001
00000001
11111111
00000000
NAME caitlyns_bedroom 45

TIL ez
11000011
11000011
11000011
11010011
11100011
11100011
11000011
00000000
NAME caitlyns_bedroom 46

TIL f0
00001111
00001111
01100001
10110001
10010001
10010001
11111111
00000000
NAME caitlyns_bedroom 47

TIL f1
01000010
01000010
01000000
01000000
01000000
01000000
01111111
00000000
NAME caitlyns_bedroom 48

TIL f2
00010000
00010000
00101111
01011111
01111111
01111111
11111111
00000000
NAME caitlyns_bedroom 49

TIL f3
00100000
00100000
11011000
11100100
11111100
11111100
11111111
00000000
NAME caitlyns_bedroom 50

TIL f4
00010000
00010000
00010000
00010000
00010000
00010000
11110000
00000000
NAME caitlyns_bedroom 51

TIL f5
11111111
11111111
11110000
11110111
11110111
11110111
11110011
11110000
NAME caitlyns_bedroom 52

TIL f6
11111111
11111111
00111110
10111110
10111110
10111110
10111101
00110001
NAME caitlyns_bedroom 53

TIL f7
11111111
11111111
00111111
10111111
10111111
11001111
11001111
11000111
NAME caitlyns_bedroom 54

TIL f8
11111111
11111111
00000111
00110100
00110100
00000100
11111111
11111111
NAME caitlyns_bedroom 55

TIL f9
11111111
11111111
00011110
11011100
11011100
00011101
11111100
11110000
NAME caitlyns_bedroom 56

TIL fa
11111111
11111111
00001111
11000111
11000111
11110111
10000011
10001011
NAME caitlyns_bedroom 57

TIL fb
11111111
11100000
11011111
11011111
11011111
11011110
11011000
11011001
NAME caitlyns_bedroom 58

TIL fc
11111111
00000000
11000011
10111001
10111001
00111101
10111101
00111101
NAME caitlyns_bedroom 59

TIL fd
11111111
01111111
10111111
10111111
10111111
10111111
10111111
10111111
NAME caitlyns_bedroom 60

TIL fe
11111111
11111111
11110000
11110000
11100111
11101111
11101011
11001111
NAME caitlyns_bedroom 61

TIL ff
11110010
11101110
01100010
01100010
00110000
10111111
11011111
11011100
NAME caitlyns_bedroom 62

TIL fg
01110111
01110011
01111011
01111011
00000011
11111111
11111111
00001111
NAME caitlyns_bedroom 63

TIL fh
11111100
00011100
00101100
00101100
00001111
11111111
11111111
11111111
NAME caitlyns_bedroom 64

TIL fi
00110010
10110010
00110000
00110000
11111111
10000001
10110000
10110010
NAME caitlyns_bedroom 65

TIL fj
11000101
11110101
00000001
00000001
11111111
11111111
11111111
11111111
NAME caitlyns_bedroom 66

TIL fk
11011001
11011001
11010001
11010001
11010111
11010111
11010000
11011111
NAME caitlyns_bedroom 67

TIL fl
01111101
00111101
10000001
10000001
11011111
10011111
00111111
11111111
NAME caitlyns_bedroom 68

TIL fm
10111111
10111111
10111111
10111111
10111111
10111111
10111111
10111111
NAME caitlyns_bedroom 69

TIL fn
11011111
11000000
11000000
11111111
11111111
11111111
11111100
11111100
NAME caitlyns_bedroom 70

TIL fo
10011101
00110001
00110001
11110011
11110011
11110011
00100011
10101110
NAME caitlyns_bedroom 71

TIL fp
11000111
01110011
01110011
01111011
01111011
01111011
01111101
01111101
NAME caitlyns_bedroom 72

TIL fq
11000111
11010111
11010111
11010111
11000111
11000111
11111111
11111111
NAME caitlyns_bedroom 73

TIL fr
10001110
10111111
10111111
10111111
10110000
10110000
00110011
01110011
NAME caitlyns_bedroom 74

TIL fs
01111111
01111111
01111111
00111111
10111111
10111111
10111111
10111111
NAME caitlyns_bedroom 75

TIL ft
11011111
11010001
11010001
11011000
11011111
11011111
11100000
11111111
NAME caitlyns_bedroom 76

TIL fu
11111111
10011100
10011100
00000110
11111100
11111100
00000000
11111111
NAME caitlyns_bedroom 77

TIL fv
10111111
10111111
10111111
10111111
10111111
10111111
01111111
11111111
NAME caitlyns_bedroom 78

TIL fw
00101110
11101111
11101111
11101111
11100000
11111111
11111111
11111111
NAME caitlyns_bedroom 79

TIL fx
00111101
11111101
11111101
11110001
00000111
11111111
11111111
11111111
NAME caitlyns_bedroom 80

TIL fy
01110001
00000000
00000000
11111111
11111111
11111111
11111111
11111111
NAME caitlyns_bedroom 81

TIL fz
11101101
11101101
11101101
11101101
11101101
11101100
11101110
11101110
NAME living_room 1

TIL g0
10111101
10111101
10111101
10111100
10111101
10111101
00000001
11111110
NAME living_room 2

TIL g1
01100000
00011111
01111111
01111100
11110001
11101001
11011001
00111001
NAME living_room 3

TIL g2
00000111
11101111
00011111
01111111
01111111
01111111
01111111
01111111
NAME living_room 4

TIL g3
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME living_room 5

TIL g4
10111111
10110000
10100110
10001111
10111111
10111111
10111111
10111111
NAME living_room 6

TIL g5
01111111
01111111
01111111
00111111
10011111
11000111
11110000
11111011
NAME living_room 7

TIL g6
11101111
11110111
11110111
11110011
11100001
11001100
00011110
01111110
NAME living_room 8

TIL g7
11010111
11010111
11010111
11010111
11010111
11010111
11010111
01010111
NAME living_room 9

TIL g8
11100000
11100111
00001111
01111110
11111001
11100101
10010101
01010101
NAME living_room 10

TIL g9
11111001
11100101
10011101
01011101
11011101
11011101
11011101
11011101
NAME living_room 11

TIL ga
10111001
10111001
10111001
10111000
10111001
10111011
10111011
00000011
NAME living_room 12

TIL gb
01111111
01111111
01111111
00000000
11111101
11110011
11001111
00111111
NAME living_room 13

TIL gc
11111110
11111110
11111110
11111110
11111110
11111110
11111111
11111111
NAME living_room 14

TIL gd
10111111
10111111
10111111
10111111
10000000
11111111
00000000
11111111
NAME living_room 15

TIL ge
11111001
11111001
11111011
11111011
00000000
11111111
00000000
11111111
NAME living_room 16

TIL gf
01111111
00111111
10111111
10111111
00000000
11111111
00000000
11111111
NAME living_room 17

TIL gg
00010111
11010111
11010111
11010111
00010111
11110111
00001111
11111111
NAME living_room 18

TIL gh
01010101
01010101
01010101
01010101
01010101
01010100
01010001
01010111
NAME living_room 19

TIL gi
11011100
11011000
11000011
00011111
01111111
11111110
11111001
11110111
NAME living_room 20

TIL gj
11111110
11111001
11110111
11001111
10111111
01111111
11111111
11111111
NAME living_room 21

TIL gk
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME living_room 22

TIL gl
11111111
11111111
11111111
11111111
11111111
11110000
11101111
10011111
NAME living_room 23

TIL gm
11111111
11111111
11111111
11111111
10000000
01111111
11111111
00000000
NAME living_room 24

TIL gn
11111111
11111111
11111111
11111111
00000000
11111111
10000000
01111111
NAME living_room 25

TIL go
11111111
11111111
11111111
11111111
00000000
11111110
00000001
11111111
NAME living_room 26

TIL gp
11111111
11111111
11111111
11111111
00000000
01111111
00000000
11111110
NAME living_room 27

TIL gq
00000111
01111111
01111110
01111001
11110111
11001111
10111111
01111111
NAME living_room 28

TIL gr
11001111
00111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME living_room 29

TIL gs
01111111
01111111
01111011
01111111
01111111
01111111
01111111
01111111
NAME living_room 30

TIL gt
00111000
01110011
01100111
01101111
01101111
01101111
01100111
11110111
NAME living_room 31

TIL gu
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME living_room 32

TIL gv
11111111
11111111
11111111
11111111
11111111
11111111
11111100
11111011
NAME living_room 33

TIL gw
11111111
11111110
11111011
11100111
11011111
00111111
11111111
11111111
NAME living_room 34

TIL gx
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME living_room 35

TIL gy
00000000
11111111
11111111
11111110
11111101
11110001
11101101
11011101
NAME living_room 36

TIL gz
00011111
11011111
00111111
11111111
01111111
01111111
01111111
01111111
NAME living_room 37

TIL h0
11111110
11111110
11111110
11111110
11111110
11111110
11111000
11110011
NAME living_room 38

TIL h1
11110111
11110111
11110111
11110111
11110111
11110111
00110111
10110111
NAME living_room 39

TIL h2
11111111
11111111
11111111
11111100
11111011
11100111
10011111
01111111
NAME living_room 40

TIL h3
11100111
11011111
00111111
11111111
11111111
11111111
11111111
11111111
NAME living_room 41

TIL h4
11111111
11111110
11111101
11110011
11101111
11011111
00111111
11111111
NAME living_room 42

TIL h5
00111101
11111101
11111101
11111101
11111101
11111101
11111111
11111101
NAME living_room 43

TIL h6
01111111
01111111
01111111
01111111
01111111
01111111
11111111
01111111
NAME living_room 44

TIL h7
11110111
11101111
11001111
10011111
10111111
10111111
00111111
01111111
NAME living_room 45

TIL h8
10110111
10010111
11010111
11010111
10010111
10010111
00010111
00110111
NAME living_room 46

TIL h9
11111111
11111111
11111111
11111111
11111111
10000000
11111111
11111111
NAME living_room 47

TIL ha
11111111
11111111
11111111
11111111
11111111
00000000
11111111
11111111
NAME living_room 48

TIL hb
11111111
11111111
11111111
11111111
11110000
00001111
11111111
11111111
NAME living_room 49

TIL hc
11111111
11111111
11111111
11111111
00000000
11111111
11111111
11111111
NAME living_room 50

TIL hd
11111111
11111111
11111111
11111111
01111111
00000000
11111111
11111111
NAME living_room 51

TIL he
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111000
NAME living_room 52

TIL hf
11111110
11111100
11111000
11101000
11101000
00111110
01100010
11000010
NAME living_room 53

TIL hg
00000011
00000110
00001100
00011000
00010000
00011000
00001100
00001111
NAME living_room 54

TIL hh
00000010
00000000
00000000
00000000
00000000
00000001
00000010
11111110
NAME living_room 55

TIL hi
11000000
01000000
01000000
01100000
10100000
10100000
10100000
10100000
NAME living_room 56

TIL hj
00000000
00000001
00000011
00000011
00000011
00000001
00000000
00000000
NAME living_room 57

TIL hk
01111110
11111110
11111001
11110001
11100010
11100010
00000110
00110110
NAME living_room 58

TIL hl
01100111
11000111
10001111
00011111
00011111
00011111
00000000
00000000
NAME living_room 59

TIL hm
11111111
11111111
11111111
11111111
11111111
11111111
00000000
00000111
NAME living_room 60

TIL hn
11111111
11111111
11111111
11111111
11111111
11111111
00000000
11111111
NAME living_room 61

TIL ho
11111111
11111111
11111111
11111111
11111111
11111111
00000011
11100000
NAME living_room 62

TIL hp
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME living_room 63

TIL hq
11111111
11111111
11111111
11111111
11111100
11111000
11100000
11000000
NAME living_room 64

TIL hr
11110001
11100011
10000010
00000010
00000110
00000100
00111100
11100100
NAME living_room 65

TIL hs
10000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME living_room 66

TIL ht
00001010
00001010
00001010
00001010
00001010
00001010
00001010
00001010
NAME living_room 67

TIL hu
10100000
10100000
10100000
10100000
10100000
10100000
11100000
00000000
NAME living_room 68

TIL hv
00100001
00100000
00111111
00110000
00100111
00100100
00100100
00100100
NAME living_room 69

TIL hw
11111111
00000000
11111111
00000000
11111111
00000000
00000000
00000000
NAME living_room 70

TIL hx
11111100
00000000
11111111
00000000
11111111
00000000
00000000
00000000
NAME living_room 71

TIL hy
00000000
00000000
11111111
00000000
11111111
00000000
00000000
00000000
NAME living_room 72

TIL hz
00000000
00000000
11111111
00000111
11110010
00010010
00010010
00010010
NAME living_room 73

TIL i0
00011111
00000000
11111111
00000000
01111111
01000000
01000000
01000000
NAME living_room 74

TIL i1
11111111
11111111
00000101
00000101
00000101
00000101
00000101
00000101
NAME living_room 75

TIL i2
10000000
00000001
00000011
00000100
00000110
00000011
00000001
00000001
NAME living_room 76

TIL i3
10000100
10000100
00000100
00000100
00000100
00000100
11100100
00111111
NAME living_room 77

TIL i4
00000010
00000010
00000010
00000110
00001010
00110010
11100010
10000010
NAME living_room 78

TIL i5
00001010
00001010
00001010
00001010
00001010
00001110
00001100
00000000
NAME living_room 79

TIL i6
00100100
00100111
00110000
00111111
00000000
00000000
00000000
00000000
NAME living_room 80

TIL i7
00000000
11111111
00000000
11111111
00000000
00000000
00000000
00000000
NAME living_room 81

TIL i8
00010010
11110010
00000111
11111111
00000000
00000000
00000000
00000000
NAME living_room 82

TIL i9
01000000
01111111
00000000
11111111
00000000
00000000
00000000
00000000
NAME living_room 83

TIL ia
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME living_room 84

TIL ib
00010100
00010100
00010100
00000100
00000100
00000100
00000100
00000100
NAME living_room 85

TIL ic
00000100
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME living_room 86

TIL id
00000000
00000000
00000000
00000000
11111111
00000001
00000000
00000000
NAME living_room 87

TIL ie
00000000
00000000
00000000
00000000
00000000
11111111
00111111
00111111
NAME living_room 88

TIL if
00000000
00000000
00000000
00000000
00000000
11111000
11111111
11111111
NAME living_room 89

TIL ig
00000000
00000000
00000000
00000000
00000000
00000000
11111100
11111111
NAME living_room 90

TIL ih
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME living_room 91

TIL ii
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11110000
NAME living_room 92

TIL ij
00000000
00000000
00000000
00000000
00000001
00000001
00000011
00000111
NAME living_room 93

TIL ik
00111111
00111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME living_room 94

TIL il
11111111
11111111
11111111
11111111
11111111
11111110
11111101
11110011
NAME living_room 95

TIL im
11111100
11111011
11110100
11010111
10101110
00011101
10000111
11111011
NAME living_room 96

TIL in
00001111
11001111
01101111
01111110
10111101
01111001
11110111
11101111
NAME living_room 97

TIL io
11011111
10001111
01110000
11111111
11111111
11111111
11111111
11111111
NAME living_room 98

TIL ip
11111111
11111111
00000000
11111111
11111111
11111111
11111111
11111111
NAME living_room 99

TIL iq
11111111
11111111
00011111
11000001
11111101
11111111
11111011
11111011
NAME living_room 100

TIL ir
11111111
11111111
11111111
11111100
11110001
11001101
11011110
11111110
NAME living_room 101

TIL is
11111111
11111111
11111111
01111111
10001111
11100000
11111111
11111111
NAME living_room 102

TIL it
11111111
11111111
11111111
11111111
10011111
00001111
11111111
00110011
NAME living_room 103

TIL iu
11111111
11111111
11111111
11111111
11110000
11101111
11101000
11101000
NAME living_room 104

TIL iv
11110000
11111111
11111111
11111111
00000011
11111100
00100111
00100100
NAME living_room 105

TIL iw
00000000
11111111
11111111
11111111
11111111
00000000
11111111
00000010
NAME living_room 106

TIL ix
00000000
11111111
11111111
11111111
11111111
00011111
11100000
10111111
NAME living_room 107

TIL iy
00000000
11111000
11111111
11111111
11111111
11111111
01111111
00000000
NAME living_room 108

TIL iz
00000111
00001111
00011111
00111111
11111111
11111110
11111001
11111011
NAME living_room 109

TIL j0
11111111
11111111
11111111
11111111
11110001
00000110
11111111
11111111
NAME living_room 110

TIL j1
11110000
11111100
11111111
11111111
11111111
00011111
11001111
10011111
NAME living_room 111

TIL j2
11110111
00101111
10011111
11111100
11111101
11110011
11110111
11101111
NAME living_room 112

TIL j3
11011111
10111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME living_room 113

TIL j4
11111011
11110111
11110111
11100111
11101111
11001111
11011111
11011111
NAME living_room 114

TIL j5
11100001
10001111
10111111
10111111
10011110
11011110
11011110
11011110
NAME living_room 115

TIL j6
11111111
11111111
01111111
01111111
01111111
11111111
11111110
11111110
NAME living_room 116

TIL j7
11111011
00110011
00110011
10011111
00101111
01101111
01101111
01101111
NAME living_room 117

TIL j8
11101000
11101000
11101000
11101000
11101000
11101000
11101100
11110100
NAME living_room 118

TIL j9
00100100
00100100
00100100
00100110
00110010
00010011
00011001
00001101
NAME living_room 119

TIL ja
00000110
00000101
00000101
00001001
00001001
00001001
00001011
00001010
NAME living_room 120

TIL jb
10001101
10000100
00000100
00000100
00000100
00000100
00000110
10000011
NAME living_room 121

TIL jc
11111111
10000000
10000000
10000000
11000000
01000000
01000000
11111110
NAME living_room 122

TIL jd
11110111
11100111
11001110
10011111
01111111
11100011
11111111
11111111
NAME living_room 123

TIL je
11111111
00111111
00111110
11111001
11110011
11111111
11001111
10011111
NAME living_room 124

TIL jf
11011111
00111111
11111110
11111101
11111101
11110011
11101111
11001111
NAME living_room 125

TIL jg
11010000
00110110
01101101
11100011
11000111
11111111
11111111
11111111
NAME living_room 126

TIL jh
11011111
10011111
10111111
10111111
10111111
01111111
01111111
11111111
NAME living_room 127

TIL ji
11011110
11011110
11011110
11011110
11011110
10011110
10111110
10111111
NAME living_room 128

TIL jj
11111111
01111111
01111111
00111111
00111111
10011111
11000111
11000111
NAME living_room 129

TIL jk
01110011
01111101
01111101
00111101
10111110
11001100
11100011
11100001
NAME living_room 130

TIL jl
11110100
11110100
11110100
11110100
11110100
11110100
11110100
11110100
NAME living_room 131

TIL jm
00001101
00001011
00001001
00001011
00001010
00001010
00001010
00001011
NAME living_room 132

TIL jn
00001110
11111100
00000100
01110100
00000110
01010010
00000010
00000110
NAME living_room 133

TIL jo
10000001
10000001
10000001
10000001
10000011
10000010
10000010
10000011
NAME living_room 134

TIL jp
01100011
01000000
11001110
10010001
10000000
10001010
10000000
11110001
NAME living_room 135

TIL jq
11111110
11111110
11111101
11110111
11111111
11111111
11111111
11111111
NAME living_room 136

TIL jr
01111111
11111111
11111110
11111101
11111011
11110111
11001111
11001111
NAME living_room 137

TIL js
10111111
00111111
01111111
11111111
11111111
11111111
11111110
11111110
NAME living_room 138

TIL jt
11111111
11100000
11000000
11011111
00111111
00111111
11111111
11111111
NAME living_room 139

TIL ju
11111111
00000000
00000000
11111111
11111111
11111111
11111111
11111111
NAME living_room 140

TIL jv
11111111
00001111
00001111
11101111
11101111
11101111
11100111
11100111
NAME living_room 141

TIL jw
11111101
11111101
11111101
11111001
11111011
11111011
11111011
11111011
NAME living_room 142

TIL jx
11111111
11111111
11111111
11111111
11111110
11111110
11111111
11111111
NAME living_room 143

TIL jy
10111111
00111110
00111110
01111110
11111100
11111100
11111000
11111000
NAME living_room 144

TIL jz
01100111
01100000
01110000
11110000
01110000
01110000
01110000
01110000
NAME living_room 145

TIL k0
11100111
00000011
00000011
11100011
11110011
11110001
11110001
11110001
NAME living_room 146

TIL k1
11110100
11110110
11110011
11111000
11111111
11111111
11111111
11111111
NAME living_room 147

TIL k2
00001101
00000100
11111111
00000000
11111111
11111111
11111111
11111111
NAME living_room 148

TIL k3
11111111
00000010
11111111
00000000
11111110
11111111
11111111
11111111
NAME living_room 149

TIL k4
10000001
00000001
10000000
11111111
00000000
11111111
11111111
11111111
NAME living_room 150

TIL k5
00011111
11000000
01111111
11000000
00001111
11111111
11111111
11111111
NAME living_room 151

TIL k6
11111111
11111111
11111111
11000000
11011111
11001111
11101111
11100101
NAME lishas bedroom 1

TIL k7
11111111
11111011
11111011
00000000
11100000
11001111
10011111
10111111
NAME lishas bedroom 2

TIL k8
11111111
11111111
11111111
00000111
11110000
00111100
10111101
10111101
NAME lishas bedroom 3

TIL k9
00000000
00000000
01111111
01000000
01111111
01000000
01111111
01111111
NAME lishas bedroom 4

TIL ka
00000000
00000000
11111111
00000000
11111111
00000000
11111111
11111111
NAME lishas bedroom 5

TIL kb
00000000
00000000
11111110
00000010
11111110
00000010
11111110
11111110
NAME lishas bedroom 6

TIL kc
00000000
00000000
00000001
00000001
00000011
00000110
00001010
00001010
NAME lishas bedroom 7

TIL kd
00000000
11111111
10000001
10000001
10000001
10010001
10101001
11000101
NAME lishas bedroom 8

TIL ke
11110101
11110100
11111010
11111011
11111011
11111101
11111101
11111101
NAME lishas bedroom 9

TIL kf
10001111
11100000
01101110
00101110
10101110
11001110
11011110
10011110
NAME lishas bedroom 10

TIL kg
00111101
01101001
11101011
11001011
10011011
00110011
11110111
01110111
NAME lishas bedroom 11

TIL kh
11111111
00111111
00001111
00000111
00000101
00000100
00000100
00000100
NAME lishas bedroom 12

TIL ki
01110000
01110000
01110000
01110000
11110000
01111111
11100000
11100001
NAME lishas bedroom 13

TIL kj
00000001
00000001
00000001
00000001
00000011
11111111
00000000
00001000
NAME lishas bedroom 14

TIL kk
10000000
10000000
10000000
11000000
11000000
11111111
00000000
01000010
NAME lishas bedroom 15

TIL kl
00001110
00001110
00001110
00001110
00001110
11111110
00000110
00010110
NAME lishas bedroom 16

TIL km
11111001
11011001
10001011
10010101
10101111
11011101
10001001
10000111
NAME lishas bedroom 17

TIL kn
11111101
11111101
11111101
11111010
11111011
10000000
10110011
10010011
NAME lishas bedroom 18

TIL ko
10111111
10111111
10111111
00000000
11111111
00000111
11110011
11110111
NAME lishas bedroom 19

TIL kp
01101111
01101111
01001111
00001111
11111111
11110111
10000001
11010100
NAME lishas bedroom 20

TIL kq
11110010
11100001
11101100
11101100
11100000
11110011
11111111
11111000
NAME lishas bedroom 21

TIL kr
10010100
00001000
01100011
01100011
00000000
11111111
00000000
00000000
NAME lishas bedroom 22

TIL ks
10100101
01000010
00011000
00011111
01110000
11000000
00000000
00000000
NAME lishas bedroom 23

TIL kt
00101110
00010110
11000110
11110110
00001110
00000110
00000110
00000110
NAME lishas bedroom 24

TIL ku
11110001
10011001
10101001
10101001
10101001
10011001
11110001
10000001
NAME lishas bedroom 25

TIL kv
11010011
11011111
11011110
11011100
11011100
11011111
11000000
11111111
NAME lishas bedroom 26

TIL kw
11110111
11100111
01101111
01101110
01101100
11101001
00001011
11111100
NAME lishas bedroom 27

TIL kx
11011110
11001010
11101110
11100010
01101110
01101110
01101101
01100001
NAME lishas bedroom 28

TIL ky
00000100
00000100
00000100
00000101
00000111
00001111
00111111
11111111
NAME lishas bedroom 29

TIL kz
11110000
11100000
01100000
11100000
01100000
01100000
01100000
01100000
NAME lishas bedroom 30

TIL l0
00001110
00001110
00001110
00001110
00001110
00011110
00010110
00011110
NAME lishas bedroom 31

TIL l1
00001010
00001010
00001010
00001110
00000011
00000001
00000001
00000000
NAME lishas bedroom 32

TIL l2
10000001
11111111
11000011
10111101
10111101
11000011
11111111
00000000
NAME lishas bedroom 33

TIL l3
11111101
11100000
11101111
11110101
11110111
11111000
11111111
11111111
NAME lishas bedroom 34

TIL l4
11111111
00111110
00111100
01111101
01111101
01111100
11111111
11111111
NAME lishas bedroom 35

TIL l5
11111111
11111111
00111111
10111111
10111111
00111111
11111111
11111111
NAME lishas bedroom 36

TIL l6
11111111
11111111
01111111
00011111
11000111
11110011
11111011
10111011
NAME lishas bedroom 37

TIL l7
01110000
01111100
01110100
01101100
01110100
01100100
01111100
01111000
NAME lishas bedroom 38

TIL l8
00111110
00100110
01100110
11010110
10101110
10010110
11000110
01000110
NAME lishas bedroom 39

TIL l9
00000000
00000001
00000001
00000001
00000000
00000001
00000001
00000001
NAME lishas bedroom 40

TIL la
11111111
01000000
01011111
01011111
01011111
11001111
01100000
00111111
NAME lishas bedroom 41

TIL lb
11110000
00101000
10101000
10101000
10100000
00111000
01101000
11001000
NAME lishas bedroom 42

TIL lc
11111111
11111111
11111111
11110111
11100111
11000111
10000111
00000111
NAME lishas bedroom 43

TIL ld
10111011
10111011
10111011
10111011
10111011
10011011
11011011
11011011
NAME lishas bedroom 44

TIL le
01110000
01100000
01100000
01100000
01110000
01110000
01111000
01111110
NAME lishas bedroom 45

TIL lf
00100110
00100110
00100110
00100110
00100110
00110110
00101110
00110110
NAME lishas bedroom 46

TIL lg
00001000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas bedroom 47

TIL lh
11111110
11111100
11111000
11110000
11100000
11000000
10000000
10000000
NAME lishas bedroom 48

TIL li
00000111
00000111
00000111
00000111
00000111
00000111
00000111
00000111
NAME lishas bedroom 49

TIL lj
11011011
10011011
11111011
11110011
11000111
00011111
01111111
11111111
NAME lishas bedroom 50

TIL lk
01111111
01111111
01000000
00100000
00000000
00000000
00000000
00000000
NAME lishas bedroom 51

TIL ll
11111111
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas bedroom 52

TIL lm
11111110
11111110
00000010
00000100
00000000
00000000
00000000
00000000
NAME lishas bedroom 53

TIL ln
10000001
11000000
11100000
11110001
11111000
11111100
11111110
11111111
NAME lishas bedroom 54

TIL lo
00000111
10000111
01000111
00000111
10000111
00000111
00000111
00000111
NAME lishas bedroom 55

TIL lp
11111111
00111111
00111111
00110011
00010001
00010001
00010001
00010001
NAME lishas bedroom 56

TIL lq
00000000
00000000
00000000
00000000
00000000
00000001
00000111
00000100
NAME lishas bedroom 57

TIL lr
00000000
00000000
00000000
00000000
00000000
11111111
01010001
00000010
NAME lishas bedroom 58

TIL ls
00000000
00000000
00000000
00000000
00000000
11100000
00111000
10000111
NAME lishas bedroom 59

TIL lt
00000000
00000000
00000000
00000000
00000000
00000000
01111110
01000010
NAME lishas bedroom 60

TIL lu
11111111
11111111
11111111
11111111
11111111
11111111
01111111
01010111
NAME lishas bedroom 61

TIL lv
10000111
11000111
11100111
11110111
11111111
11111111
11111111
11111111
NAME lishas bedroom 62

TIL lw
00010001
00110001
00110001
00110001
00110001
00110001
00110001
00010001
NAME lishas bedroom 63

TIL lx
00001100
00001010
00011100
00011000
00010000
00101000
00110000
00101000
NAME lishas bedroom 64

TIL ly
01010001
00101000
00000101
00000000
00000000
00000000
00000000
00000000
NAME lishas bedroom 65

TIL lz
01010001
00001010
01010001
00100100
00010001
00001010
00000001
00000000
NAME lishas bedroom 66

TIL m0
11000000
11100000
01110000
10111000
01011100
10100110
01010110
00101010
NAME lishas bedroom 67

TIL m1
00000000
00000000
00000000
00000001
00000001
00000001
00000000
00000000
NAME lishas bedroom 68

TIL m2
11000011
10000001
10000001
11111111
00000000
10000001
10000001
11111111
NAME lishas bedroom 69

TIL m3
00000000
00000000
00000000
10000000
10000000
10000000
00000000
00000000
NAME lishas bedroom 70

TIL m4
01010111
01010101
01010101
01010101
11010101
10010101
10010101
10010101
NAME lishas bedroom 71

TIL m5
00010001
00010001
00010001
00010001
00110011
00111111
00111111
11111111
NAME lishas bedroom 72

TIL m6
00110000
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME lishas bedroom 73

TIL m7
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01111000
NAME lishas bedroom 74

TIL m8
00000000
00000000
00000000
00000000
00000100
00000100
00001100
01111000
NAME lishas bedroom 75

TIL m9
01010110
00101010
00010110
00101010
01010110
00101010
00010110
00001010
NAME lishas bedroom 76

TIL ma
00000000
00100000
01000000
11111111
11000000
10010000
10000000
11010011
NAME lishas bedroom 77

TIL mb
00000000
00000000
00000000
11111111
00000000
00000000
00000000
11000000
NAME lishas bedroom 78

TIL mc
10000001
10000001
00000000
11111111
00000001
00111001
00101001
00101001
NAME lishas bedroom 79

TIL md
00000000
00000000
00000000
11111111
11111111
10111110
01011101
00100010
NAME lishas bedroom 80

TIL me
00000000
00000100
00000010
11111111
11000011
11000001
01000001
01000001
NAME lishas bedroom 81

TIL mf
11110101
00010101
00010101
01110101
01010101
10010101
10010101
11010101
NAME lishas bedroom 82

TIL mg
00100000
00110000
00010000
00010000
00010000
00010000
00010000
00011000
NAME lishas bedroom 83

TIL mh
00001111
00000000
00000000
00000000
00000001
01000000
10000000
00000000
NAME lishas bedroom 84

TIL mi
11000000
00000000
00001000
00000100
00000000
10000000
00000000
00000000
NAME lishas bedroom 85

TIL mj
00000110
00001010
00010110
00001100
00010100
00001100
00010100
00001100
NAME lishas bedroom 86

TIL mk
10010001
11000111
11101000
10101011
11111011
11011011
11111011
11111100
NAME lishas bedroom 87

TIL ml
10000000
11100000
00010000
11010000
11010000
11010000
11010000
00110000
NAME lishas bedroom 88

TIL mm
00111001
00001001
00001111
00000000
00000001
00000001
00000001
00000001
NAME lishas bedroom 89

TIL mn
01010101
00101010
10111110
01111111
11000001
00111110
01111111
01111111
NAME lishas bedroom 90

TIL mo
01000001
01000001
11000001
00000001
11000001
01000001
01000001
01000001
NAME lishas bedroom 91

TIL mp
00000000
00011000
00100100
01000010
01111110
10000001
10111101
10111101
NAME lishas bedroom 92

TIL mq
00000000
00000000
00000001
00000011
00000111
00011110
00111100
01110000
NAME lishas bedroom 93

TIL mr
01010101
01010111
11111111
11111111
11111111
11111111
11111111
11111111
NAME lishas bedroom 94

TIL ms
00001000
00001000
00001100
00000110
00000011
00000000
00000000
00000000
NAME lishas bedroom 95

TIL mt
00000000
00000000
00000000
00000000
10000000
11111111
00000000
00000000
NAME lishas bedroom 96

TIL mu
00000000
00000000
00000000
00000000
00000011
11111110
00000000
00000000
NAME lishas bedroom 97

TIL mv
00001000
00010000
00110000
11000000
10000000
00000000
00000000
00000000
NAME lishas bedroom 98

TIL mw
11000111
11111111
00000000
00000000
11111111
11111111
11111111
11111111
NAME lishas bedroom 99

TIL mx
11100000
11111111
00000000
00000000
11111111
11111111
11111111
11111111
NAME lishas bedroom 100

TIL my
00000001
11111111
00000000
00000000
11111111
11111111
11111111
11111111
NAME lishas bedroom 101

TIL mz
11111111
11111111
00000000
00000000
11111111
11111111
11111111
11111111
NAME lishas bedroom 102

TIL n0
11000011
11111111
00000000
00000000
11111111
11111111
11111111
11111111
NAME lishas bedroom 103

TIL n1
10111101
10000001
01111110
00000000
00000000
00000000
00000000
00000000
NAME lishas bedroom 104

TIL n2
00000001
00000011
00000111
00011110
00111100
01110000
00100000
00000000
NAME lishas bedroom 105

TIL n3
11100000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME lishas bedroom 106

TIL n4
11100111
11000011
10100101
11100111
11100111
11100111
11100111
11111111
>
11111111
11100111
11000011
10100101
11100111
11100111
11100111
11100111

TIL n5
00000000
00000000
00000001
00000111
00001111
00010111
00110001
00111101
NAME dream 1

TIL n6
00000000
00000000
11111011
11111001
11111101
11111101
11111101
11111101
NAME dream 2

TIL n7
00000000
00000000
11101100
11100011
11111001
11111110
11111111
11111111
NAME dream 3

TIL n8
00000000
00000011
00000011
10000111
11110111
00111111
10001111
11101111
NAME dream 4

TIL n9
00011111
11111111
11111111
11111111
11111111
11111110
11111100
11111001
NAME dream 5

TIL na
11011111
10011111
10111111
00111111
01111111
01111111
11111111
11111111
NAME dream 6

TIL nb
11111111
10111111
10111111
10111111
10111111
10011111
11011111
11011111
NAME dream 7

TIL nc
00000000
11100000
11110000
11111000
11111111
11111111
11111111
11111111
NAME dream 8

TIL nd
00000000
00000000
00000000
00000000
00000000
00000000
10000000
11000000
NAME dream 9

TIL ne
00111110
01111110
01111110
01111110
01111110
01111100
01111101
11111011
NAME dream 10

TIL nf
11111101
11111101
11111001
11111011
11110011
11110111
11101111
11101111
NAME dream 11

TIL ng
11101111
11101111
11101111
11001111
11011111
10011111
10111111
00111111
NAME dream 12

TIL nh
11110011
11100111
11001111
11011111
10011111
10111111
10111111
10111111
NAME dream 13

TIL ni
11011111
11011111
11011111
11001111
11101111
11101111
11101111
11101111
NAME dream 14

TIL nj
11100000
11100000
11100000
11100000
11100000
11100000
11000001
10010111
NAME dream 15

TIL nk
00000000
00000000
00000000
00000000
00011111
01111111
11111111
11111111
NAME dream 16

TIL nl
00000000
00000000
00000000
00000000
11111111
11111111
11111111
11111111
NAME dream 17

TIL nm
00000000
00000000
00000000
00000000
10000000
11100000
11111000
11111000
NAME dream 18

TIL nn
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME dream 19

TIL no
00000000
00000000
00000000
00000000
00001111
01111111
11111111
11111111
NAME dream 20

TIL np
00000001
00000001
00000001
00000011
11111111
11111111
11111111
11111111
NAME dream 21

TIL nq
11111011
11111011
11111011
11111011
11111001
11111100
11111111
11111111
NAME dream 22

TIL nr
11101111
11101111
11101111
11100011
11111001
00000000
11111111
11111111
NAME dream 23

TIL ns
11111111
11111111
11111111
11111111
11111111
00111111
00001111
10001111
NAME dream 24

TIL nt
01111111
01111111
00111111
10011111
11000111
11110111
11110011
11111011
NAME dream 25

TIL nu
10111111
10111111
10111111
10111111
11011111
11011111
10011111
10111111
NAME dream 26

TIL nv
11111111
11111111
11111111
11111111
11111111
11111111
11111100
11111001
NAME dream 27

TIL nw
11101111
11101110
11101110
11001110
10011100
00111101
01111001
11000111
NAME dream 28

TIL nx
01111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME dream 29

TIL ny
11111100
11111100
11111111
11111111
11111111
11111111
11111111
11111111
NAME dream 30

TIL nz
00000000
00000000
00000000
00000000
10000000
10000000
11000000
11000000
NAME dream 31

TIL o0
00001111
00001111
00011111
00011111
00111111
00111111
00111111
00111111
NAME dream 32

TIL o1
11010111
11100111
11100111
11101011
11100011
11110011
11100011
11000011
NAME dream 33

TIL o2
11111011
11110011
11110110
11100110
11101110
11101110
11101110
11101110
NAME dream 34

TIL o3
00111111
01111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME dream 35

TIL o4
11111010
11110100
11100001
11100011
11100111
11101111
11101111
11111111
NAME dream 36

TIL o5
00011111
11111111
11111111
11111111
11111111
11001111
10000111
00000011
NAME dream 37

TIL o6
11000000
11000000
11000000
11100000
11100000
11110000
11100000
11100000
NAME dream 38

TIL o7
00111111
00111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME dream 39

TIL o8
11010111
11010111
11000111
11001111
11000111
11000001
11111111
11111111
NAME dream 40

TIL o9
11100110
11110011
11111000
11111111
11111111
11111111
11111111
11111111
NAME dream 41

TIL oa
01111111
00011111
00001111
10000111
11100111
11110111
11111111
11111111
NAME dream 42

TIL ob
11111111
11101111
11101111
11101111
11100100
11100011
10000011
00000111
NAME dream 43

TIL oc
00000001
00010000
10100000
10100000
11100010
00111110
00001100
00000011
NAME dream 44

TIL od
11110011
00000001
00000001
00000001
00000001
00000001
00000001
10100000
NAME dream 45

TIL oe
11000000
11000000
11000000
11000000
10000000
10000000
10000000
00000000
NAME dream 46

TIL of
01111111
01111111
00111111
00111111
00111111
00111111
00111111
00111111
NAME dream 47

TIL og
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111100
NAME dream 48

TIL oh
11111111
11111111
11111111
11111111
11111111
11110000
00000000
00000011
NAME dream 49

TIL oi
11111111
11111111
11111110
11111110
00000000
00000001
00111111
11111111
NAME dream 50

TIL oj
11111111
11111111
00000000
00000000
00000000
11111111
11111100
11110000
NAME dream 51

TIL ok
11111000
11111000
00101111
00101111
11000111
00001000
00001000
00001000
NAME dream 52

TIL ol
00000000
00000011
11000011
11000011
00000000
00000000
00000000
00000000
NAME dream 53

TIL om
00000001
00000001
10000000
10000000
10000000
10000000
11000000
11000000
NAME dream 54

TIL on
11100000
11000000
01000000
01000000
01011000
00110000
00100001
00010010
NAME dream 55

TIL oo
00011111
00000111
00000111
00000111
00000111
00000111
00000111
00000111
NAME dream 56

TIL op
11111111
11111100
11111110
11111111
11111111
11111111
11111111
11111111
NAME dream 57

TIL oq
00000000
00000000
00000000
11000000
11110000
11111000
11111100
11111110
NAME dream 58

TIL or
00011111
00011111
00000111
00000111
00000111
00000111
00000011
00000011
NAME dream 59

TIL os
11111111
11111111
11111111
11111110
11111110
11111110
11111100
11111100
NAME dream 60

TIL ot
11110000
11000001
00001111
00011111
00011111
00111111
11111110
11111111
NAME dream 61

TIL ou
00011111
11111111
11111111
11111111
11111111
11111111
01111111
11111110
NAME dream 62

TIL ov
11111111
11111111
11111100
11111000
11111000
11000000
00000000
00000000
NAME dream 63

TIL ow
00001000
00001110
00000111
00000000
00000000
00000000
00000000
00000000
NAME dream 64

TIL ox
00000000
00000000
10001111
11110000
11110000
00000000
00000000
00000000
NAME dream 65

TIL oy
01000000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME dream 66

TIL oz
00001110
00000111
00000000
00000000
00000000
00000000
00000000
00000000
NAME dream 67

TIL p0
00000001
00010000
11110000
00011000
00011000
00001100
00000101
00000111
NAME dream 68

TIL p1
11111111
11111111
00001111
00000011
00000011
00000001
00000011
00000111
NAME dream 69

TIL p2
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000011
NAME dream 70

TIL p3
11111001
11111001
11111001
11111001
11111001
11111001
11111001
11111001
NAME dream 71

TIL p4
11111000
11111111
11100000
11100000
11100000
11100000
11100000
11100000
NAME dream 72

TIL p5
00000000
11000000
00111111
00000000
00000000
00000000
00000000
00000000
NAME dream 73

TIL p6
00000011
00000000
11111111
00000000
00000000
00000000
00000000
00000000
NAME dream 74

TIL p7
10000101
11111100
11111000
11111000
11111100
11111100
11111100
11111100
NAME dream 75

TIL p8
11111111
11111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME dream 76

TIL p9
00000111
00000111
00001111
00001111
00001111
00001111
00001111
00001111
NAME dream 77

TIL pa
11111001
11111100
11111110
11111110
11111111
11111111
11111111
11111111
NAME dream 78

TIL pb
11111111
11111111
00111111
00001111
00000111
00000111
11100001
11110000
NAME dream 79

TIL pc
11100000
11100000
11111111
11111111
11111111
11111111
11111111
00011111
NAME dream 80

TIL pd
00000000
00000000
11111111
11111111
11111111
11111111
11011111
11111001
NAME dream 81

TIL pe
00000000
00000000
10000000
11111111
11111111
11111111
11111011
11111111
NAME dream 82

TIL pf
00000000
00000000
00000000
11111111
11111111
11111111
11111111
11111111
NAME dream 83

TIL pg
11111000
11111000
11110000
11110000
11000000
11000000
11000001
00000011
NAME dream 84

TIL ph
11111111
11111111
11111110
11111100
11111000
11100000
11000000
00000000
NAME dream 85

TIL pi
00001111
00001111
00001111
00001111
00001111
00001111
00001111
00001111
NAME dream 86

TIL pj
00000001
00000000
11110000
11111100
11111111
11111111
11111111
11111111
NAME dream 87

TIL pk
11111111
00111111
00000001
00000000
00000000
11100000
11100000
11111100
NAME dream 88

TIL pl
11111111
11111111
11111111
00011111
00000000
00000000
00000000
00000000
NAME dream 89

TIL pm
11111111
11111111
11111111
11111111
00000000
00000000
00000000
00000000
NAME dream 90

TIL pn
11111111
11111111
11111111
11111111
00111111
00000000
00000000
00000000
NAME dream 91

TIL po
11111111
11111111
11111111
11111111
11100000
00000000
00000000
00000000
NAME dream 92

TIL pp
11111111
11111111
11111100
11100000
00000000
00000000
00000000
00000001
NAME dream 93

TIL pq
11100000
00000000
00000000
00000000
00000001
00001111
00001111
11111111
NAME dream 94

TIL pr
00000011
00001111
00111111
11111111
11111111
11111111
11111111
11111111
NAME dream 95

TIL ps
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME dream 96

TIL pt
00001111
00000111
00000111
00000011
00000011
00000000
00000000
00000000
NAME dream 97

TIL pu
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME dream 98

TIL pv
00000000
10000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME dream 99

TIL pw
00000000
00001111
11111111
11111111
11111111
11111111
11111111
11111111
NAME dream 100

TIL px
11111000
11111000
11111000
11111000
11110000
11110000
11110000
11110000
NAME dream 101

TIL py
01111111
00011111
00000111
00000000
00000000
00000000
00000000
00000000
NAME dream 102

TIL pz
11111111
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME dream 103

TIL q0
11111111
11100001
10000000
00000000
00000000
00000000
00000000
00000000
NAME dream 104

TIL q1
11111111
11111111
11111111
01111111
00111111
00011111
00000111
00000001
NAME dream 105

TIL q2
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11110000
NAME dream 106

TIL q3
11111111
11100011
11100000
11000000
10000000
00000000
00000000
00000000
NAME dream 107

TIL q4
11111111
11111111
11111111
00111111
00001111
00000011
00000000
00000000
NAME dream 108

TIL q5
11111111
11111111
11111111
11111111
11111111
11111110
00000000
00000000
NAME dream 109

TIL q6
11110000
11100000
11100000
10000000
10000000
00000000
00000000
00000000
NAME dream 110

TIL q7
11111111
01111111
00001111
00000000
00000000
00000000
00000000
00000000
NAME dream 111

TIL q8
11111111
11111100
11100000
00000000
00000000
00000000
00000000
00000000
NAME dream 112

TIL q9
00000000
00000011
00001111
00001111
00000111
00001111
00001111
00001111
NAME dream 113

TIL qa
11111100
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME dream 114

TIL qb
00000000
10000000
11000000
11100000
11100000
11100000
11100000
11100000
NAME dream 115

TIL qc
00000000
00000000
00000000
00000000
00000000
00111110
01111111
01111111
NAME dream 116

TIL qd
00001111
00000111
00000011
00000001
00000000
00000000
10000000
11000000
NAME dream 117

TIL qe
11111111
11111111
11111111
10111111
00000000
00000000
00000000
00000000
NAME dream 118

TIL qf
11100000
11000000
11000000
11000000
00000000
00000000
00000000
00000000
NAME dream 119

TIL qg
00000000
00000000
00000000
00000000
00000000
00000000
00111000
11111100
NAME dream 120

TIL qh
11111111
11111111
11111111
11111111
01011111
00000000
00000000
00000000
NAME dream 121

TIL qi
11000000
11000000
11000000
11000000
11000000
00000000
00000000
00000000
NAME dream 122

TIL qj
11111110
11111110
11111100
11111100
00100000
00000000
00000000
00000000
NAME dream 123

TIL qk
11111101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME dream 124

TIL ql
11011111
11011111
11011111
11001110
11101111
11101111
11101111
11101111
NAME dream 125

TIL qm
00000000
00000000
00000001
00000011
11111111
11111111
11111111
11111111
NAME dream 126

TIL qn
01111110
11111011
11111101
11111111
11111111
11111111
11111111
11111111
NAME dream 127

TIL qo
00011111
00011111
00000111
00000011
00000011
00000011
00000011
00000011
NAME dream 128

TIL qp
00000001
00000001
00000001
00000001
00000001
00000000
00000000
00000011
NAME dream 129

TIL qq
00000011
00000111
00000111
00001111
00001111
00001111
00001111
00001111
NAME dream 130

TIL qr
00000111
00000111
00000011
00000011
00000000
00000000
00000000
00000000
NAME dream 131

TIL qs
11111111
11111111
11111111
00111111
00011111
00000111
00000011
00000000
NAME dream 132

TIL qt
11111111
00011111
00000001
00000000
00000000
00000000
00000000
00000000
NAME dream 133

TIL qu
11111111
11111000
00000000
00000000
00000000
00000000
00000000
00000000
NAME dream 134

TIL qv
11011111
11011111
11011101
11001110
11101111
11101111
11101111
11101111
NAME dream 135

TIL qw
11111111
11111111
01111111
00111111
00011111
00000111
00000011
00000000
NAME dream 136

TIL qx
11111111
11111100
11000000
00000000
00000000
00000000
00000000
00000000
NAME dream 137

TIL qy
00000001
00000001
00000011
00000111
11111111
11111111
11111111
11111111
NAME dream 138

TIL qz
00011111
00011111
00000111
00000111
00000111
00000111
00000111
00000011
NAME dream 139

TIL r0
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000111
NAME dream 140

TIL r1
00000111
00000111
00001111
00001111
00001111
00001111
00011111
00011111
NAME dream 141

TIL r2
00011111
00011111
00011111
00011111
00011111
00011111
00011111
00001111
NAME dream 142

TIL r3
00001111
00001111
00000111
00000111
00000011
00000000
00000000
00000000
NAME dream 143

TIL r4
11111111
11100011
10000000
00000000
00000000
00000000
00000000
00000000
NAME dream 144

TIL r5
11111111
11110011
11100000
11000000
10000000
00000000
00000000
00000000
NAME dream 145

TIL r6
11111111
11111100
11110000
00000000
00000000
00000000
00000000
00000000
NAME dream 146

TIL r7
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL r8
11111111
11111111
11111111
11111111
11111111
11111111
00000000
00000000

SPR A
00111100
00111100
00011000
00111101
01111110
10111100
00100100
00100100
>
00111100
00111100
00011000
10111100
01111110
00111101
00011000
00011000
POS 15 7,15

SPR a
00011000
00111100
00111100
01111100
01011100
01111110
00101000
00111100
>
00011000
00111100
00111100
01111110
01011010
10111101
01000100
01100110
NAME amira

SPR b
01111110
01011010
00011000
01111110
11111111
10111101
10111101
00100100
>
01111110
01011010
00011000
00111100
01111110
11111111
10111101
00100100
NAME caitlyn
DLG SPR_0
POS 12 5,3

SPR c
00011000
00111100
01011010
00011000
00011000
00011000
00000000
00000000
DLG SPR_1
POS 8 8,13

ITM 0
11111111
10000001
10111101
10000001
10111011
10000100
10001000
11111000
NAME note
DLG ITM_0

ITM 1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME dream
DLG ITM_1

ITM 2
00000000
00111100
01000010
10000001
10000001
01000010
00111100
00000000
NAME empty plate
DLG ITM_2

DLG ITM_0
On a {wvy}run{wvy}, gotta work off those calories! - Amira

DLG ITM_1
"""
Mmm! I smell pumpkin spice. I see the deep orange and golden brown edges. I can taste the light sweetness of cinnamon and a crumbly crust. 

What a wonderful dream. Time to wake up and actually eat the slice of pie in the kitchen.  
"""

DLG ITM_2
The plate is empty! WHO ATE MY PIE?

DLG SPR_0
"""
{
  - {item "empty plate"} < 1 ?
    Good morning. Get out of my room!
    {metCaitlyn = 1}
  - {item "empty plate"} >= 1 ?
    I didn't eat your pie, princess.
    {metCaitlyn = 2}
}
"""

DLG SPR_1
"""
{
  - metCaitlyn < 2 ?
    Come talk to me once you've heard from Caitlyn or Amira! 
  - {item "note"} < 1 ?
    Come talk to me once you've heard from Caitlyn or Amira! 
  - metCaitlyn == 2 ?
    (end) I saw it all last night. You scurried from your room into the kitchen. You consumed the slice of pie all in one chomp and licked your fingers. You skipped back to bed and nodded off with a full tummy! Case closed.
}
"""


VAR metCaitlyn
0


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#000;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
	touch-action: none; /* fixing touch-input errors in chrome */

	/* sharp pixel edges */
	/* https://caniuse.com/#search=image-render */
  	-ms-interpolation-mode: nearest-neighbor; /* IE */
  	image-rendering: -moz-crisp-edges; /* FF 6.0+ */
  	image-rendering: pixelated; /* Chrome, Safari */
}

</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	attachCanvas( document.getElementById("game") );
	load_game( document.getElementById("exportedGameData").text.slice(1) );
}
</script>

<script>
//hex-to-rgb method borrowed from stack overflow
function hexToRgb(hex) {
	// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	hex = hex.replace(shorthandRegex, function(m, r, g, b) {
		return r + r + g + g + b + b;
	});

	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16)
	} : null;
}
function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function hslToHex(h,s,l) {
    var rgbArr = hslToRgb(h,s,l);
    return rgbToHex( Math.floor(rgbArr[0]), Math.floor(rgbArr[1]), Math.floor(rgbArr[2]) );
}

function hexToHsl(hex) {
    var rgb = hexToRgb(hex);
    return rgbToHsl(rgb.r, rgb.g, rgb.b);
}

// really just a vector distance
function colorDistance(a1,b1,c1,a2,b2,c2) {
    return Math.sqrt( Math.pow(a1 - a2, 2) + Math.pow(b1 - b2, 2) + Math.pow(c1 - c2, 2) );
}

function hexColorDistance(hex1,hex2) {
    var color1 = hexToRgb(hex1);
    var color2 = hexToRgb(hex2);
    return rgbColorDistance(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b);
}


// source : http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR 
 * h, s, v
*/
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/* accepts parameters
 * r  Object = {r:x, g:y, b:z}
 * OR 
 * r, g, b
*/
function RGBtoHSV(r, g, b) {
    if (arguments.length === 1) {
        g = r.g, b = r.b, r = r.r;
    }
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return {
        h: h,
        s: s,
        v: v
    };
}

// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ r * 255, g * 255, b * 255 ];
}

/**
 * From: http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @return  {Array}           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;
	var effectImage = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var frameRate = 8; // cap the FPS
	var prevStep = -1; // used to avoid running post-process effect constantly

	this.BeginTransition = function(startRoom,startX,startY,endRoom,endX,endY,effectName) {
		// console.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		drawRoom(room[startRoom]);
		var startPalette = getPal( room[startRoom].pal );
		var startImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) ); // TODO : don't use global ctx?
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		drawRoom(room[endRoom]);
		var endPalette = getPal( room[endRoom].pal );
		var endImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) );
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		effectImage = new PostProcessImage( ctx.createImageData(canvas.width,canvas.height) );

		isTransitioning = true;
		transitionTime = 0;
		prevStep = -1;

		player().room = tmpRoom;
		player().x = tmpX;
		player().y = tmpY;
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var transitionDelta = transitionTime / transitionEffects[curEffect].duration;
		var maxStep = Math.floor(frameRate * (transitionEffects[curEffect].duration / 1000));
		var step = Math.floor(transitionDelta * maxStep);

		if (step != prevStep) {
			// console.log("step! " + step + " " + transitionDelta);
			for (var y = 0; y < effectImage.Height; y++) {
				for (var x = 0; x < effectImage.Width; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart,transitionEnd,x,y,(step / maxStep));
					effectImage.SetPixel(x,y,color);
				}
			}
		}
		prevStep = step;

		ctx.putImageData(effectImage.GetData(), 0, 0);

		if (transitionTime >= transitionEffects[curEffect].duration) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			effectImage = null;
			prevStep = -1;
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:255,g:255,b:255,a:255};
			var pixelColorB = delta < 0.5 ? {r:255,g:255,b:255,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:0,g:0,b:0,a:255};
			var pixelColorB = delta < 0.5 ? {r:0,g:0,b:0,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX,pixelY);
		}
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return start.Image.GetPixel(pixelX,pixelY);
				}
			}
			else if (delta <= 0.6)
			{
				return {r:0,g:0,b:0,a:255};
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return end.Image.GetPixel(pixelX,pixelY);
				}
			}
		}
	});

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY >= 0) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY += start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY < start.Image.Height) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY -= start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX >= 0) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX += start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX < start.Image.Width) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX -= start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	function clampLerp(deltaIn, clampDuration) {
		var clampOffset = (1.0 - clampDuration) / 2;
		var deltaOut = Math.min(clampDuration, Math.max(0.0, deltaIn - clampOffset)) / clampDuration;
		return deltaOut;
	}

	// TODO : WIP
	// this.RegisterTransitionEffect("fuzz", {
	// 	showPlayerStart : true,
	// 	showPlayerEnd : true,
	// 	duration : 1500,
	// 	pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
	// 		var curImage = delta <= 0.5 ? start : end;
	// 		var sampleSize = delta <= 0.5 ? (2 + Math.floor(14 * (delta/0.5))) : (16 - Math.floor(14 * ((delta-0.5)/0.5)));

	// 		var palIndex = 0;

	// 		var sampleX = Math.floor(pixelX / sampleSize) * sampleSize;
	// 		var sampleY = Math.floor(pixelY / sampleSize) * sampleSize;

	// 		var frameState = transitionEffects["fuzz"].frameState;

	// 		if (frameState.time != delta) {
	// 			frameState.time = delta;
	// 			frameState.preCalcSampleValues = {};
	// 		}

	// 		if (frameState.preCalcSampleValues[[sampleX,sampleY]]) {
	// 			palIndex = frameState.preCalcSampleValues[[sampleX,sampleY]];
	// 		}
	// 		else {
	// 			var paletteCount = {};
	// 			var foregroundValue = 1.0;
	// 			var backgroundValue = 0.4;
	// 			for (var y = sampleY; y < sampleY + sampleSize; y++) {
	// 				for (var x = sampleX; x < sampleX + sampleSize; x++) {
	// 					var color = curImage.Image.GetPixel(x,y)
	// 					var palIndex = PostProcessUtilities.GetColorPalIndex(color,curImage.Palette);
	// 					if (palIndex != -1) {
	// 						if (paletteCount[palIndex]) {
	// 							paletteCount[palIndex] += (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 						else {
	// 							paletteCount[palIndex] = (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 					}
	// 				}
	// 			}

	// 			var maxCount = 0;
	// 			for (var i in paletteCount) {
	// 				if (paletteCount[i] > maxCount) {
	// 					palIndex = i;
	// 					maxCount = paletteCount[i];
	// 				}
	// 			}

	// 			frameState.preCalcSampleValues[[sampleX,sampleY]] = palIndex;
	// 		}

	// 		return PostProcessUtilities.GetPalColor(curImage.Palette,palIndex);
	// 	},
	// 	frameState : { // ok this is hacky but it's for performance ok
	// 		time : -1,
	// 		preCalcSampleValues : {}
	// 	}
	// });
}; // TransitionManager()


// TODO : extract the scale variable so it can be changed?
var PostProcessUtilities = {
	SamplePixelColor : function(image,x,y) {
		var pixelIndex = (y * scale * image.width * 4) + (x * scale * 4);
		var r = image.data[pixelIndex + 0];
		var g = image.data[pixelIndex + 1];
		var b = image.data[pixelIndex + 2];
		var a = image.data[pixelIndex + 3];
		return { r:r, g:g, b:b, a:a };
	},
	SetPixelColor : function(image,x,y,colorRgba) {
		for (var yDelta = 0; yDelta <= scale; yDelta++) {
			for (var xDelta = 0; xDelta <= scale; xDelta++) {
				var pixelIndex = (((y * scale) + yDelta) * image.width * 4) + (((x * scale) + xDelta) * 4);
				image.data[pixelIndex + 0] = colorRgba.r;
				image.data[pixelIndex + 1] = colorRgba.g;
				image.data[pixelIndex + 2] = colorRgba.b;
				image.data[pixelIndex + 3] = colorRgba.a;
			}
		}
	},
	LerpColor : function(colorA,colorB,t) {
		// TODO: move to color_util.js?
		return {
			r : colorA.r + ((colorB.r - colorA.r) * t),
			g : colorA.g + ((colorB.g - colorA.g) * t),
			b : colorA.b + ((colorB.b - colorA.b) * t),
			a : colorA.a + ((colorB.a - colorA.a) * t),
		};
	},
	GetColorPalIndex : function(colorIn,curPal) {
		var colorIndex = -1;

		for (var i = 0; i < curPal.length; i++) {
			if (colorIn.r == curPal[i][0] && colorIn.g == curPal[i][1] && colorIn.b == curPal[i][2]) {
				colorIndex = i;
			}
		}

		return colorIndex;
	},
	GetPalColor : function(palette,index) {
		return { r: palette[index][0], g: palette[index][1], b: palette[index][2], a: 255 }
	},
	GetCorrespondingColorFromPal : function(colorIn,curPal,otherPal) { // this is kind of hacky!
		var colorIndex = PostProcessUtilities.GetColorPalIndex(colorIn,curPal);

		if (colorIndex >= 0 && colorIndex <= otherPal.length) {
			return PostProcessUtilities.GetPalColor(otherPal,colorIndex);
		}
		else {
			return colorIn;
		}
	},
};

var PostProcessImage = function(imageData) {
	this.Width = imageData.width / scale;
	this.Height = imageData.height / scale;

	this.GetPixel = function(x,y) {
		return PostProcessUtilities.SamplePixelColor(imageData,x,y);
	};

	this.SetPixel = function(x,y,colorRgba) {
		PostProcessUtilities.SetPixelColor(imageData,x,y,colorRgba);
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;
	this.Palette = palette;
	this.PlayerTilePos = { x: playerX, y: playerY };
	this.PlayerCenter = { x: Math.floor((playerX * tilesize) + (tilesize / 2)), y: Math.floor((playerY * tilesize) + (tilesize / 2)) };
};
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};
	var invalidCharData = {};

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function parseFont(fontData) {
		if (fontData == null)
			return;

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];

			if (line[0] === "#") {
				continue; // skip comment lines
			}

			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = { 
						width: width,
						height: height,
						offset: {
							x: 0,
							y: 0
						},
						spacing: width,
						data: []
					};
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= height) {
						isReadingChar = false;
					}
				}
			}
		}

		// init invalid character box
		invalidCharData = { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width, // TODO : name?
			data: []
		};
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// console.log("COMPILE");
		var script = parser.Parse( scriptStr );
		env.SetScript( scriptName, script );
	}
	this.Run = function(scriptName, exitHandler) { // Runs pre-compiled script
		// console.log("RUN");
		// console.log(env.GetScript( scriptName ));
		env.GetScript( scriptName )
			.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );

		// console.log("SERIALIZE!!!!");
		// console.log( env.GetScript( scriptName ).Serialize() );
	}
	this.Interpret = function(scriptStr, exitHandler) { // Compiles and runs code immediately
		// console.log("INTERPRET");
		var script = parser.Parse( scriptStr );
		script.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr) { // parses a script but doesn't save it
		return parser.Parse( scriptStr );
	}
	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		scriptTree.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );
	}

	function OnScriptReturn(result, exitHandler) {
		if (isReturnObject(result)) {
			result = result.result; // pull out the contained result
		}

		// console.log("RESULT " + result);

		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression( expStr );
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	this.DebugVisualizeScriptTree = function(scriptName) {
		var printVisitor = {
			Visit : function(node,depth) {
				console.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		env.GetScript( scriptName ).VisitAll( printVisitor );
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if(doIndentFirstLine === undefined) doIndentFirstLine = true;
		var block = new BlockNode( BlockMode.Dialog, doIndentFirstLine );
		for(var i = 0; i < children.length; i++) {
			block.AddChild( children[i] );
		}
		return block;
	}

	this.ChangeSequenceType = function(oldSequence,type) {
		if(type === "sequence") {
			return new SequenceNode( oldSequence.options );
		}
		else if(type === "cycle") {
			return new CycleNode( oldSequence.options );
		}
		else if(type === "shuffle") {
			return new ShuffleNode( oldSequence.options );
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var option2 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new BlockNode( BlockMode.Code );
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new BlockNode( BlockMode.Dialog );
		var result2 = new BlockNode( BlockMode.Dialog );

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	console.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

// TODO : vNext
// function returnFunc(environment,parameters,onReturn) {
// 	var ret = { isReturn: true, result: null };
// 	if (parameters.length > 0 && parameters[0] != undefined && parameters[0] != null) {
// 		ret.result = parameters[0];
// 	}
// 	onReturn(ret);
// }

// TODO : vNext
// // TODO : this is kind of hacky
// // - needs to work with names too
// function changeAvatarFunc(environment,parameters,onReturn) {
// 	if( parameters[0] != undefined && parameters[0] != null ) {
// 		sprite["A"].drw = "SPR_" + parameters[0];
// 	}
// 	onReturn(null);
// }

function printFunc(environment,parameters,onReturn) {
	// console.log("PRINT FUNC");
	// console.log(parameters);
	if( parameters[0] != undefined && parameters[0] != null ) {
		// console.log(parameters[0]);
		// console.log(parameters[0].toString());
		// var textStr = parameters[0].toString();
		var textStr = "" + parameters[0];
		// console.log(textStr);
		var onFinishHandler = function() {
			// console.log("FINISHED PRINTING ---- SCRIPT");
			onReturn(null);
		}; // called when dialog is finished printing
		environment.GetDialogBuffer().AddText( textStr, onFinishHandler );
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment,parameters,onReturn) {
	// console.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	onReturn(null);
}

function printDrawingFunc(environment,parameters,onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing( drawingId, function() {
		onReturn(null);
	});
}

function printSpriteFunc(environment,parameters,onReturn) {
	var spriteId = parameters[0];
	if(names.sprite.has(spriteId)) spriteId = names.sprite.get(spriteId); // id is actually a name
	var drawingId = sprite[spriteId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
	var tileId = parameters[0];
	if(names.tile.has(tileId)) tileId = names.tile.get(tileId); // id is actually a name
	var drawingId = tile[tileId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var drawingId = item[itemId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get( fontName );
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	printFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var itemCount = player().inventory[itemId] ? player().inventory[itemId] : 0; // TODO : ultimately the environment should include a reference to the game state
	// console.log("ITEM FUNC " + itemId + " " + itemCount);
	onReturn(itemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// console.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// console.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// console.log("EVAL EQUAL");
	// console.log(left);
	// console.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = new Map();
	functionMap.set("print", printFunc);
	functionMap.set("say", printFunc);
	functionMap.set("br", linebreakFunc);
	functionMap.set("item", itemFunc);
	functionMap.set("rbw", rainbowFunc);
	functionMap.set("clr1", color1Func);
	functionMap.set("clr2", color2Func);
	functionMap.set("clr3", color3Func);
	functionMap.set("wvy", wavyFunc);
	functionMap.set("shk", shakyFunc);
	functionMap.set("printSprite", printSpriteFunc);
	functionMap.set("printTile", printTileFunc);
	functionMap.set("printItem", printItemFunc);
	functionMap.set("debugOnlyPrintFont", printFontFunc); // DEBUG ONLY

	// TODO : vNext
	// functionMap.set("changeAvatar", changeAvatarFunc);
	// functionMap.set("return", returnFunc);

	this.HasFunction = function(name) { return functionMap.has(name); };
	this.EvalFunction = function(name,parameters,onReturn) {
		// console.log(functionMap);
		// console.log(name);
		functionMap.get( name )( this, parameters, onReturn );
	}

	var variableMap = new Map();

	this.HasVariable = function(name) { return variableMap.has(name); };
	this.GetVariable = function(name) { return variableMap.get(name); };
	this.SetVariable = function(name,value,useHandler) {
		// console.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap.set(name, value);
		if(onVariableChangeHandler != null && useHandler)
			onVariableChangeHandler(name);
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap.has(name)) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler)
				onVariableChangeHandler(name);
		}
	};

	var operatorMap = new Map();
	operatorMap.set("=", setExp);
	operatorMap.set("==", equalExp);
	operatorMap.set(">", greaterExp);
	operatorMap.set("<", lessExp);
	operatorMap.set(">=", greaterEqExp);
	operatorMap.set("<=", lessEqExp);
	operatorMap.set("*", multExp);
	operatorMap.set("/", divExp);
	operatorMap.set("+", addExp);
	operatorMap.set("-", subExp);

	this.HasOperator = function(sym) { return operatorMap.get(sym); };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap.get( sym )( this, left, right, onReturn );
	}

	var scriptMap = new Map();
	this.HasScript = function(name) { return scriptMap.has(name); };
	this.GetScript = function(name) { return scriptMap.get(name); };
	this.SetScript = function(name,script) { scriptMap.set(name, script); };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		return Array.from( variableMap.keys() );
	}
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// console.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];
	this.AddChild = function(node) {
		this.children.push( node );
		node.parent = this;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.children.length; i++ ) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};
}

function isReturnObject(val) {
	return typeof val === "object" && val != null
				&& val.isReturn != undefined && val.isReturn != null
				&& val.isReturn;
}

var BlockMode = {
	Code : "code",
	Dialog : "dialog"
};

var BlockNode = function(mode, doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "block";
	this.mode = mode;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if( this.onEnter != null ) {
			this.onEnter();
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children,done) {
			if (i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval( environment, function(val) {
					// console.log("<< CHILD " + i);

					if (isReturnObject(val)) { // early return
						lastVal = val;
						done();
					}
					else {
						lastVal = val;
						i++;
						evalChildren(children,done);
					}
				} );
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren( this.children, function() {
			if( self.onExit != null ) {
				self.onExit();
			}
			onReturn(lastVal);
		} );
	}

	if(doIndentFirstLine === undefined) doIndentFirstLine = true; // This is just for serialization

	this.Serialize = function(depth) {
		if(depth === undefined) depth = 0;

		// console.log("SERIALIZE BLOCK!!!");
		// console.log(depth);
		// console.log(doIndentFirstLine);

		var str = "";
		var lastNode = null;
		if (this.mode === BlockMode.Code) str += "{"; // todo: increase scope of Sym?
		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			if(curNode.type === "block" && lastNode && lastNode.type === "block" && !isBlockWithNoNewline(curNode) && !isBlockWithNoNewline(lastNode))
				str += "\n";

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");
			if(this.mode === BlockMode.Dialog && (shouldIndentFirstLine || shouldIndentAfterLinebreak))
				str += leadingWhitespace(depth);
			str += curNode.Serialize(depth);
			lastNode = curNode;
		}
		if (this.mode === BlockMode.Code) str += "}";
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

function isBlockWithNoNewline(node) {
	return isTextEffectBlock(node) || isMultilineListBlock(node);
}

function isTextEffectBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			if(func.name === "clr1" || func.name === "clr2" || func.name === "clr3" || func.name === "wvy" || func.name === "shk" || func.name === "rbw") {
				return true;
			}
		}
	}
	return false;
}

function isMultilineListBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0) {
			var child = node.children[0];
			if(child.type === "sequence" || child.type === "cycle" || child.type === "shuffle" || child.type === "if") {
				return true;
			}
		}
	}
	return false;
}

var FuncNode = function(name,arguments) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.arguments = arguments;

	this.Eval = function(environment,onReturn) {

		if( this.onEnter != null ) this.onEnter();

		// console.log("FUNC");
		// console.log(this.arguments);
		var argumentValues = [];
		var i = 0;
		function evalArgs(arguments,done) {
			if(i < arguments.length) {
				// Evaluate each argument
				arguments[i].Eval( environment, function(val) {
					argumentValues.push( val );
					i++;
					evalArgs(arguments,done);
				} );
			}
			else {
				done();
			}
		};
		var self = this; // hack to deal with scope
		evalArgs( this.arguments, function() {
			// Then evaluate the function
			// console.log("ARGS");
			// console.log(argumentValues);

			if( self.onExit != null ) self.onExit();

			environment.EvalFunction( self.name, argumentValues, onReturn );
		} );
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.mode && this.parent.mode === BlockMode.Dialog;
		if(isDialogBlock && this.name === "print") {
			// TODO this could cause problems with "real" print functions
			return this.arguments[0].value; // first argument should be the text of the {print} func
		}
		else if(isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.arguments.length; i++) {
				str += " ";
				str += this.arguments[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name;
	};
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if(this.value === null)
			return str;

		if(typeof this.value === "string") str += '"';
		str += this.value;
		if(typeof this.value === "string") str += '"';

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.value;
	};
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name;
	};
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// console.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if(!isNegativeNumber) {
			var str = "";
			str += this.left.Serialize(depth);
			str += " " + this.operator + " ";
			str += this.right.Serialize(depth);
			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator;
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.options.length; i++) {
			// console.log("SERIALIZE SEQUENCE ");
			// console.log(depth);
			str += leadingWhitespace(depth + 1) + Sym.List + " " + this.options[i].Serialize(depth + 2) + "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.options.length; i++ ) {
			this.options[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type;
	};
}

var SequenceNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "sequence";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("SEQUENCE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
	}
}

var CycleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "cycle";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("CYCLE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
		else
			index = 0;
	}
}

var ShuffleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "shuffle";
	this.options = options;

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while(optionsUnshuffled.length > 0) {
			var i = Math.floor( Math.random() * optionsUnshuffled.length );
			optionsShuffled.push( optionsUnshuffled.splice(i,1)[0] );
		}
	}
	shuffle(this.options);

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// OLD RANDOM VERSION
		// var index = Math.floor(Math.random() * this.options.length);
		// this.options[index].Eval( environment, onReturn );

		optionsShuffled[index].Eval( environment, onReturn );
		
		index++;
		if (index >= this.options.length) {
			shuffle(this.options);
			index = 0;
		}
	}
}

var IfNode = function(conditions, results, isSingleLine) {
	Object.assign( this, new TreeRelationship() );
	this.type = "if";
	this.conditions = conditions;
	this.results = results;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL IF");
		var i = 0;
		var self = this;
		function TestCondition() {
			// console.log("EVAL " + i);
			self.conditions[i].Eval(environment, function(val) {
				// console.log(val);
				if(val == true) {
					self.results[i].Eval(environment, onReturn);
				}
				else if(i+1 < self.conditions.length) {
					i++;
					TestCondition(); // test next condition
				}
				else {
					onReturn(null); // out of conditions and none were true
				}
			});
		};
		TestCondition();
	}

	if(isSingleLine === undefined) isSingleLine = false; // This is just for serialization

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			str += this.conditions[0].Serialize() + " ? " + this.results[0].Serialize();
			if(this.conditions.length > 1 && this.conditions[1].type === "else")
				str += " : " + this.results[1].Serialize();
		}
		else {
			str += "\n";
			for (var i = 0; i < this.conditions.length; i++) {
				str += leadingWhitespace(depth + 1) + Sym.List + " " + this.conditions[i].Serialize(depth) + " ?\n";
				str += this.results[i].Serialize(depth + 2) + "\n";
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.conditions.length; i++ ) {
			this.conditions[i].VisitAll( visitor, depth + 1 );
		}
		for( var i = 0; i < this.results.length; i++ ) {
			this.results[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "else";

	this.Eval = function(environment,onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return "else";
	}

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

var Sym = {
	// DialogOpen : "/\"",
	// DialogClose : "\"/",
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"'
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr) {
		// console.log("NEW PARSE!!!!!!");

		// TODO : make this work for single-line, no dialog block scripts

		var state = new ParserState( new BlockNode(BlockMode.Dialog), scriptStr );

		if( state.MatchAhead(Sym.DialogOpen) ) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );
			state = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
			state = ParseDialog( state );
		}
		// else if( state.MatchAhead(Sym.CodeOpen) ) { // NOTE: This causes problems when you lead with a code block
		// 	// code-block: should this ever happen?
		// 	state = ParseCodeBlock( state );
		// }
		else {
			// single-line dialog block
			state = ParseDialog( state );
		}

		// console.log( state.rootNode );
		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// console.log(str);
			str = "" + str; // hack to turn single chars into strings
			// console.log(str);
			// console.log(str.length);
			for(var j = 0; j < str.length; j++) {
				if( i + j >= sourceStr.length )
					return false;
				else if( str[j] != sourceStr[i+j] )
					return false;
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// console.log(j);
			while(j < sourceStr.length && end.indexOf( sourceStr[j] ) == -1 ) {
				str += sourceStr[j];
				j++;
			}
			// console.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function( open, close ) {
			var startIndex = i;

			var matchCount = 0;
			if( this.MatchAhead( open ) ) {
				matchCount++;
				this.Step( open.length );
			}

			while( matchCount > 0 && !this.Done() ) {
				if( this.MatchAhead( close ) ) {
					matchCount--;
					this.Step( close.length );
				}
				else if( this.MatchAhead( open ) ) {
					matchCount++;
					this.Step( open.length );
				}
				else {
					this.Step();
				}
			}

			// console.log("!!! " + startIndex + " " + i);

			return sourceStr.slice( startIndex + open.length, i - close.length );
		}
		this.Print = function() { console.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	function ParseDialog(state) {
		// console.log("PARSE DIALOG");
		state.Print();

		// for linebreak logic: add linebreaks after lines with dialog or empty lines (if it's not the very first line)
		var hasBlock = false;
		var hasDialog = false;
		var isFirstLine = true;

		// console.log("---- PARSE DIALOG ----");

		var text = "";
		var addTextNode = function() {
			// console.log("TEXT " + text.length);
			if (text.length > 0) {
				// console.log("TEXT " + text);
				// console.log("text!!");
				// console.log([text]);

				state.curNode.AddChild( new FuncNode( "print", [new LiteralNode(text)] ) );
				text = "";

				hasDialog = true;
			}
		}

		while ( !state.Done() ) {

			if( state.MatchAhead(Sym.CodeOpen) ) {
				addTextNode();
				state = ParseCodeBlock( state );

				// console.log("CODE");

				var len = state.curNode.children.length;
				if(len > 0 && state.curNode.children[len-1].type === "block") {
					var block = state.curNode.children[len-1];
					if(isMultilineListBlock(block))
						hasDialog = true; // hack to get correct newline behavior for multiline blocks
				}

				hasBlock = true;
			}
			// NOTE: nested dialog blocks disabled for now
			// else if( state.MatchAhead(Sym.DialogOpen) ) {
			// 	addTextNode();
			// 	state = ParseDialogBlock( state ); // These can be nested (should they though???)

			// 	hasBlock = true;
			// }
			else {
				if ( state.MatchAhead(Sym.Linebreak) ) {
					addTextNode();

					/*
					NOTES:
					linebreaks SHOULD happen on
					- lines with text (including the first or last line)
					- empty lines (that are NOT the first or last line)
					linebreaks should NOT happen on
					- lines with only CODE blocks
					- empty FIRST or LAST lines

					also, apparently:
					- NEVER line break on the last line
					*/
					var isLastLine = (state.Index() + 1) == state.Count();
					// console.log("block " + hasBlock);
					// console.log("dialog " + hasDialog);
					var isEmptyLine = !hasBlock && !hasDialog;
					// console.log("empty " + isEmptyLine);
					var isValidEmptyLine = isEmptyLine && !(isFirstLine || isLastLine);
					// console.log("valid empty " + isValidEmptyLine);
					var shouldAddLinebreak = (hasDialog || isValidEmptyLine) && !isLastLine; // last clause is a hack (but it works - why?)
					// console.log("LINEBREAK? " + shouldAddLinebreak);
					if( shouldAddLinebreak ) {
						// console.log("NEWLINE");
						// console.log("empty? " + isEmptyLine);
						// console.log("dialog? " + hasDialog);
						state.curNode.AddChild( new FuncNode( "br", [] ) ); // use function or character?
					}

					// linebreak logic
					isFirstLine = false;
					hasBlock = false;
					hasDialog = false;

					text = "";
				}
				else {
					text += state.Char();
				}
				state.Step();
			}

		}
		addTextNode();

		// console.log("---- PARSE DIALOG ----");

		// console.log(state);
		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	function ParseIf(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var isNewline = true;
		var isConditionDone = false;
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				curIndex++;
				isConditionDone = false;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}
			else if(curIndex > -1) {
				if(!isConditionDone) {
					if(state.Char() === "?" || state.Char() === "\n") { // TODO: use Sym
						// end of condition
						isConditionDone = true;
					}
					else {
						// read in condition
						conditionStrings[curIndex] += state.Char();
					}
				}
				else {
					// read in result
					if(!isSkippableWhitespace)
						resultStrings[curIndex] += state.Char();
				}
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			state.Step();
		}

		// console.log("PARSE IF:");
		// console.log(conditionStrings);
		// console.log(resultStrings);

		var conditions = [];
		for(var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if(str === "else") {
				conditions.push( new ElseNode() );
			}
			else {
				var exp = CreateExpression( str );
				conditions.push( exp );
			}
		}

		var results = [];
		for(var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			results.push( dialogBlock );
		}

		state.curNode.AddChild( new IfNode( conditions, results ) );

		return state;
	}

	function IsSequence(str) {
		// console.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	// TODO: don't forget about eating whitespace
	function ParseSequence(state, sequenceType) {
		// console.log("SEQUENCE " + sequenceType);
		state.Print();

		var isNewline = false;
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				// console.log("found next list item");
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}
			else if(curItemIndex > -1) {
				if(!isSkippableWhitespace)
					itemStrings[curItemIndex] += state.Char();
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			// console.log(state.Char());
			state.Step();
		}
		// console.log(itemStrings);
		// console.log("SEQUENCE DONE");

		var options = [];
		for(var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState( new BlockNode( BlockMode.Dialog, false /* doIndentFirstLine */ ), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			options.push( dialogBlock );
		}

		// console.log(options);

		if(sequenceType === "sequence")
			state.curNode.AddChild( new SequenceNode( options ) );
		else if(sequenceType === "cycle")
			state.curNode.AddChild( new CycleNode( options ) );
		else if(sequenceType === "shuffle")
			state.curNode.AddChild( new ShuffleNode( options ) );

		return state;
	}

	function ParseFunction(state, funcName) {
		console.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// console.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// console.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState( new BlockNode(BlockMode.Code), state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose ) );
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// console.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// console.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState( new BlockNode( BlockMode.Code ), codeStr );
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// console.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// console.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// console.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// console.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	var setSymbol = "=";
	var ifSymbol = "?";
	var elseSymbol = ":";
	var operatorSymbols = ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"]; // operators need to be in reverse order of precedence
	function CreateExpression(expStr) {
		console.log("CREATE EXPRESSION --- " + expStr);

		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(setSymbol);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = setSymbol;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+setSymbol.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(ifSymbol);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = ifSymbol;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+ifSymbol.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(elseSymbol); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+elseSymbol.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < operatorSymbols.length); i++ ) {
			var opSym = operatorSymbols[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var nonWhitespaceCount = 0;

		while (!tempState.Done()) {
			if( IsWhitespace(tempState.Char()) ) {
				tempState.Step(); // consume whitespace
			}
			else if( tempState.MatchAhead(Sym.CodeOpen) ) {
				tempState.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
			}
			else {
				nonWhitespaceCount++;
				tempState.Step();
			}
		}

		var isExpression = nonWhitespaceCount > 0;
		return isExpression;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// console.log("EXPRESSION " + line);
		var exp = CreateExpression( line );
		// console.log(exp);
		state.curNode.AddChild( exp );
		state.Step( line.length );
		return state;
	}

	function ParseCode(state) {
		console.log("PARSE CODE --- " + state.Source());

		// skip leading whitespace
		while (IsWhitespace(state.Char())) {
			state.Step();
		}

		if( state.Char() === Sym.List && (state.Peak([]).indexOf("?") > -1) ) { // TODO : symbols? matchahead?
			// console.log("PEAK IF " + state.Peak( ["?"] ));
			state = ParseIf( state );
		}
		else if( environment.HasFunction( state.Peak( [" "] ) ) ) { // TODO --- what about newlines???
			var funcName = state.Peak( [" "] );
			state.Step( funcName.length );
			state = ParseFunction( state, funcName );
		}
		else if( IsSequence( state.Peak( [" ", Sym.Linebreak] ) ) ) {
			var sequenceType = state.Peak( [" ", Sym.Linebreak] );
			state.Step( sequenceType.length );
			state = ParseSequence( state, sequenceType );
		}
		else if (IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			// multi-line code block
			while (!state.Done()) {
				if( state.MatchAhead(Sym.CodeOpen) ) {
					state = ParseCodeBlock( state );
				}
				else {
					state.Step();
				}
			}
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );

		// console.log("PARSE CODE");
		// console.log(codeStr);

		var codeState = new ParserState( new BlockNode(BlockMode.Code), codeStr );
		codeState = ParseCode( codeState );
		
		state.curNode.AddChild( codeState.rootNode );

		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		img : null,
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		font_scale : 0.5, // we draw font at half-size compared to everything else
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
	}

	function textScale() {
		return scale * textboxInfo.font_scale;
	}

	function relativeFontWidth() {
		return Math.ceil( font.getWidth() * textboxInfo.font_scale );
	}

	function relativeFontHeight() {
		return Math.ceil( font.getHeight() * textboxInfo.font_scale );
	}

	var context = null;
	this.AttachContext = function(c) {
		context = c;
	};

	this.ClearTextbox = function() {
		if(context == null) return;

		//create new image none exists
		if(textboxInfo.img == null)
			textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);

		// fill text box with black
		for (var i=0;i<textboxInfo.img.data.length;i+=4)
		{
			textboxInfo.img.data[i+0]=0;
			textboxInfo.img.data[i+1]=0;
			textboxInfo.img.data[i+2]=0;
			textboxInfo.img.data[i+3]=255;
		}
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if(context == null) return;
		if (isCentered) {
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
		}
		else if (player().y < mapsize/2) {
			//bottom
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
		}
		else {
			//top
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];
	this.DrawNextArrow = function() {
		// console.log("draw arrow!");
		var top = (textboxInfo.height-5) * scale;
		var left = (textboxInfo.width-(5+4)) * scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < scale; sy++) {
						for (var sx = 0; sx < scale; sx++) {
							var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
							textboxInfo.img.data[pxl+0] = 255;
							textboxInfo.img.data[pxl+1] = 255;
							textboxInfo.img.data[pxl+2] = 255;
							textboxInfo.img.data[pxl+3] = 255;
						}
					}
				}
			}
		}
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col, leftPos) {
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		}; // compute render offset *every* frame

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var top = (4 * scale) + (row * 2 * scale) + (row * font.getHeight() * text_scale) + Math.floor( char.offset.y );
		var left = (4 * scale) + (leftPos * text_scale) + Math.floor( char.offset.x );

		var debug_r = Math.random() * 255;

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {

				var i = (y * char.width) + x;
				if ( charData[i] == 1 ) {

					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
							textboxInfo.img.data[pxl+0] = char.color.r;
							textboxInfo.img.data[pxl+1] = char.color.g;
							textboxInfo.img.data[pxl+2] = char.color.b;
							textboxInfo.img.data[pxl+3] = char.color.a;
						}
					}
				}
				// else {
				// 	// DEBUG

				// 	//scaling nonsense
				// 	for (var sy = 0; sy < text_scale; sy++) {
				// 		for (var sx = 0; sx < text_scale; sx++) {
				// 			var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
				// 			textboxInfo.img.data[pxl+0] = debug_r;
				// 			textboxInfo.img.data[pxl+1] = 0;
				// 			textboxInfo.img.data[pxl+2] = 0;
				// 			textboxInfo.img.data[pxl+3] = 255;
				// 		}
				// 	}
				// }

			}
		}
		
		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer,dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar( this.DrawChar );

		if( buffer.CanContinue() )
			this.DrawNextArrow();

		this.DrawTextbox();

		if( buffer.DidPageFinishThisFrame() && onPageFinish != null )
			onPageFinish();
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	}

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// console.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// console.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		// console.log("DO NEXT CHAR");

		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;

			// console.log("WAITING FOR INPUT");
		}

		// console.log(this.CurChar());
		if(this.CurChar() != null)
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		console.log("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	this.Continue = function() {
		console.log("CONTINUE");
		if (pageIndex + 1 < this.CurPageCount()) {
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = { r:255, g:255, b:255, a:255 };
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// console.log("SET POS");
			// console.log(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// console.log("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// console.log("FX " + effectName);
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				console.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var charData = font.getChar(char);
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var imageData = renderer.GetImageSource(drawingId)[0];
		var imageDataFlat = [];
		for (var i = 0; i < imageData.length; i++) {
			// console.log(imageData[i]);
			imageDataFlat = imageDataFlat.concat(imageData[i]);
		}

		this.bitmap = imageDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogFontChar( font, word[i], effectList ) );
		}
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddDrawing = function(drawingId, onFinishHandler) {
		// console.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects)
		drawingChar.SetPrintHandler( onFinishHandler );

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0)
		{
			//stay on same row
			curRowArr.push( drawingChar );
		}
		else if (curRowIndex == 0)
		{
			//start next row
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer[ curPageIndex ].push( [] );
			curRowIndex++;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}
		else {
			//start next page
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer.push( [] );
			curPageIndex++;
			buffer[ curPageIndex ].push( [] );
			curRowIndex = 0;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr,onFinishHandler) {
		// console.log("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth( wordWithPrecedingSpace );

			var rowLength = GetCharArrayWidth(curRowArr);

			if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray( curRowArr, wordWithPrecedingSpace, activeTextEffects );
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer[ curPageIndex ].push( [] );
				curRowIndex++;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
			else {
				//start next page
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer.push( [] );
				curPageIndex++;
				buffer[ curPageIndex ].push( [] );
				curRowIndex = 0;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[ buffer.length-1 ];
		var lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length == 0 )
			lastPage.splice( lastPage.length-1, 1 );
		if( lastPage.length == 0 )
			buffer.splice( buffer.length-1, 1 );

		//finish up 
		lastPage = buffer[ buffer.length-1 ];
		lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length > 0 ) {
			var lastChar = lastRow[ lastRow.length-1 ];
			lastChar.SetPrintHandler( onFinishHandler );
		}

		console.log(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[ buffer.length-1 ];
		if( lastPage.length <= 1 ) {
			console.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push( [] );
		}
		else {
			// add new page
			buffer.push( [[]] );
		}
		console.log(buffer);

		isActive = true;
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() { // TODO - should it be an object or just a method?
	this.DoEffect = function(char,time) {
		// console.log("RAINBOW!!!");
		// console.log(char);
		// console.log(char.color);
		// console.log(char.col);

		var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
		var rgb = hslToRgb( h, 1, 0.5 );
		char.color.r = rgb[0];
		char.color.g = rgb[1];
		char.color.b = rgb[2];
		char.color.a = 255;
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		var pal = getPal( curPal() );
		var color = pal[ parseInt( index ) ];
		// console.log(color);
		char.color.r = color[0];
		char.color.g = color[1];
		char.color.b = color[2];
		char.color.a = 255;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func,time,offset,mult1,mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 3
						* disturb(Math.sin,time,char.col,0.1,0.5)
						* disturb(Math.cos,time,char.col,0.3,0.2)
						* disturb(Math.sin,time,char.row,2.0,1.0);
		char.offset.x += 3
						* disturb(Math.cos,time,char.row,0.1,1.0)
						* disturb(Math.sin,time,char.col,3.0,0.7)
						* disturb(Math.cos,time,char.col,0.2,0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

} // Dialog()
</script>

<script>
/*
TODO
- reset renderer function
- react to changes in: drawings, palettes
- possible future plan: limit size of cache (remove old images)
- change image store path from (pal > col > draw) to (draw > pal > col)
- get rid of old getSpriteImage (etc) methods
- get editor working again [in progress]
- move debug timer class into core (seems useful)
*/

function Renderer(tilesize, scale) {

console.log("!!!!! NEW RENDERER");

var imageStore = { // TODO : rename to imageCache
	source: {},
	render: {}
};

var palettes = null; // TODO : need null checks?
var context = null;

function setPalettes(paletteObj) {
	palettes = paletteObj;

	// TODO : should this really clear out the render cache?
	imageStore.render = {};
}

function getPaletteColor(paletteId, colorIndex) {
	if (palettes[paletteId] === undefined) {
		paletteId = "default";
	}

	var palette = palettes[paletteId];

	if (colorIndex > palette.colors.length) { // do I need this failure case? (seems un-reliable)
		colorIndex = 0;
	}

	var color = palette.colors[colorIndex];

	return {
		r : color[0],
		g : color[1],
		b : color[2]
	};
}

var debugRenderCount = 0;

// TODO : change image store path from (pal > col > draw) to (draw > pal > col)
function renderImage(drawing, paletteId) {
	// debugRenderCount++;
	// console.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;
	var imgSrc = imageStore.source[ drawing.drw ];

	// initialize render cache entry
	if (imageStore.render[drwId] === undefined || imageStore.render[drwId] === null) {
		imageStore.render[drwId] = {};
	}

	if (imageStore.render[drwId][pal] === undefined || imageStore.render[drwId][pal] === null) {
		imageStore.render[drwId][pal] = {};
	}

	// create array of ImageData frames
	imageStore.render[drwId][pal][colStr] = [];

	for (var i = 0; i < imgSrc.length; i++) {
		var frameSrc = imgSrc[i];
		var frameData = imageDataFromImageSource( frameSrc, pal, col );
		imageStore.render[drwId][pal][colStr].push(frameData);
	}
}

function imageDataFromImageSource(imageSource, pal, col) {
	//console.log(imageSource);

	var img = context.createImageData(tilesize*scale,tilesize*scale);

	var backgroundColor = getPaletteColor(pal,0);
	var foregroundColor = getPaletteColor(pal,col);

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = imageSource[y][x];
			for (var sy = 0; sy < scale; sy++) {
				for (var sx = 0; sx < scale; sx++) {
					var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
					if ( px === 1 ) {
						img.data[pxl + 0] = foregroundColor.r;
						img.data[pxl + 1] = foregroundColor.g;
						img.data[pxl + 2] = foregroundColor.b;
						img.data[pxl + 3] = 255;
					}
					else { //ch === 0
						img.data[pxl + 0] = backgroundColor.r;
						img.data[pxl + 1] = backgroundColor.g;
						img.data[pxl + 2] = backgroundColor.b;
						img.data[pxl + 3] = 255;
					}
				}
			}
		}
	}

	// convert to canvas: chrome has poor performance when working directly with image data
	var imageCanvas = document.createElement("canvas");
	imageCanvas.width = img.width;
	imageCanvas.height = img.height;
	var imageContext = imageCanvas.getContext("2d");
	imageContext.putImageData(img,0,0);

	return imageCanvas;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isImageRendered(drawing, paletteId) {
	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;

	if (undefinedOrNull(imageStore.render[drwId]) ||
		undefinedOrNull(imageStore.render[drwId][pal]) ||
		undefinedOrNull(imageStore.render[drwId][pal][colStr])) {
			return false;
	}
	else {
		return true;
	}
}

function getImageSet(drawing, paletteId) {
	return imageStore.render[drawing.drw][paletteId][drawing.col];
}

function getImageFrame(drawing, paletteId, frameOverride) {
	var frameIndex = 0;
	if (drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getImageSet(drawing, paletteId)[frameIndex];
}

function getOrRenderImage(drawing, paletteId, frameOverride) {
	if (!isImageRendered(drawing, paletteId)) {
		renderImage(drawing, paletteId);
	}

	return getImageFrame(drawing, paletteId, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetImage = getOrRenderImage;

this.SetPalettes = setPalettes;

this.SetImageSource = function(drawingId, imageSourceData) {
	imageStore.source[drawingId] = imageSourceData;
	imageStore.render[drawingId] = {}; // reset render cache for this image
}

this.GetImageSource = function(drawingId) {
	return imageStore.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return imageStore.source[drawingId].length;
}

this.AttachContext = function(ctx) {
	context = ctx;
}

} // Renderer()
</script>

<script>
var xhr; // TODO : remove
var canvas;
var context; // TODO : remove if safe?
var ctx;

var title = "";
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var ending = {};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};
var textDirection = TextDirection.LeftToRight;

var names = {
	room : new Map(),
	tile : new Map(), // Note: Not currently enabled in the UI
	sprite : new Map(),
	item : new Map(),
	/*dialog : new Map()*/ // TODO
	/*ending : new Map()*/ // TODO
};
function updateNamesFromCurData() {
	names.room = new Map();
	for(id in room) {
		if(room[id].name != undefined && room[id].name != null) {
			names.room.set( room[id].name, id );
		}
	}
	names.tile = new Map();
	for(id in tile) {
		if(tile[id].name != undefined && tile[id].name != null) {
			names.tile.set( tile[id].name, id );
		}
	}
	names.sprite = new Map();
	for(id in sprite) {
		if(sprite[id].name != undefined && sprite[id].name != null) {
			names.sprite.set( sprite[id].name, id );
		}
	}
	names.item = new Map();
	for(id in item) {
		if(item[id].name != undefined && item[id].name != null) {
			names.item.set( item[id].name, id );
		}
	}
}

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 6, // major changes
	minor: 4 // smaller changes
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
	// NONE right now!
};

function clearGameData() {
	title = "";
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	ending = {};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	spriteStartLocations = {};

	names = {
		room : new Map(),
		tile : new Map(),
		sprite : new Map(),
		item : new Map()
	};

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var prevTime = 0;
var deltaTime = 0;

//methods used to trigger gif recording
var didPlayerMoveThisFrame = false;
var onPlayerMoved = null;
// var didDialogUpdateThisFrame = false;
var onDialogUpdate = null;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new Renderer(tilesize, scale);

function getGameNameFromURL() {
	var game = window.location.hash.substring(1);
	// console.log("game name --- " + game);
	return game;
}

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
	dialogRenderer.AttachContext(ctx);
	renderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data, startWithTitle) {
	curGameData = game_data; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

	parseWorld(game_data);

	if (!isPlayerEmbeddedInEditor) {
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), document.getElementById(defaultFontName).text.slice(1));
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	setInitialVariables();

	// setInterval(updateLoadingScreen, 300); // hack test

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();
	load_game(curGameData);

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

var update_interval = null;
function onready(startWithTitle) {
	if(startWithTitle === undefined || startWithTitle === null) startWithTitle = true;

	clearInterval(loading_interval);

	input = new InputManager();

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart);
		canvas.addEventListener('touchmove', input.ontouchmove);
		canvas.addEventListener('touchend', input.ontouchend);
	}
	else {
		//borksy modification, fixing touch controls on itch.io mobile embeds

	  	let existingTouchTrigger = document.querySelector('#touchTrigger');
	  	if (existingTouchTrigger === null){
	  	  var touchTrigger = document.createElement("div");
	  	  touchTrigger.setAttribute("id","touchTrigger");
	  	  touchTrigger.setAttribute(
	  	    "style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
	  	  );
	  	  document.body.appendChild(touchTrigger);

	  	  touchTrigger.addEventListener('touchstart', input.ontouchstart);
	  	  touchTrigger.addEventListener('touchmove', input.ontouchmove);
	  	  touchTrigger.addEventListener('touchend', input.ontouchend);
	  	}
	}

	window.onblur = input.onblur;

	update_interval = setInterval(update,16);

	if(startWithTitle) { // used by editor 
		startNarrating(title);
	}
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

// TODO: this is likely broken
function breadthFirstSearch(map, from, to) {
	from.trail = [];
	var visited = [];
	var queue = [from];
	visited.push( posToString(from) );

	//console.log( "~ bfs ~");
	//console.log( posToString(from) + " to " + posToString(to) );

	while ( queue.length > 0 ) {

		//grab pos from queue and mark as visited
		var curPos = queue.shift();

		//console.log( posToString(curPos) );
		//console.log( ".. " + pathToString(curPos.trail) );
		//console.log( visited );

		if (curPos.x == to.x && curPos.y == to.y) {
			//found a path!
			var path = curPos.trail.splice(0);
			path.push( curPos );
			return path;
		}

		//look at neighbors
		neighbors(curPos).forEach( function(n) {
			var inBounds = (n.x >= 0 && n.x < 16 && n.y >= 0 && n.y < 16);
			if (inBounds) {
				var noCollision = map[n.y][n.x] <= 0;
				var notVisited = visited.indexOf( posToString(n) ) == -1;
				if (noCollision && notVisited) {
					n.trail = curPos.trail.slice();
					n.trail.push(curPos);
					queue.push( n );
					visited.push( posToString(n) );
				}
			}
		});

	}

	return []; // no path found
}

function posToString(pos) {
	return pos.x + "," + pos.y;
}

function pathToString(path) {
	var s = "";
	for (i in path) {
		s += posToString(path[i]) + " ";
	}
	return s;
}

function neighbors(pos) {
	var neighborList = [];
	neighborList.push( {x:pos.x+1, y:pos.y+0} );
	neighborList.push( {x:pos.x-1, y:pos.y+0} );
	neighborList.push( {x:pos.x+0, y:pos.y+1} );
	neighborList.push( {x:pos.x+0, y:pos.y-1} );
	return neighborList;
}

function collisionMap(roomId) {
	var map = [
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	];

	for (r in room[roomId].tilemap) {
		var row = room[roomId].tilemap[r];
		for (var c = 0; c < row.length; c++) {
			if (room[roomId].walls.indexOf( row[x] ) != -1) {
				map[r][c] = 1;
			}
		}
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			map[spr.y][spr.x] = 2;
		}
	}

	return map;
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	console.log("stop GAME!");

	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		//borksy modifications

    	let existingTouchTrigger = document.querySelector('#touchTrigger');
    	if (existingTouchTrigger !== null){
    		existingTouchTrigger.removeEventListener('touchstart', input.ontouchstart);
    		existingTouchTrigger.removeEventListener('touchmove', input.ontouchmove);
    		existingTouchTrigger.removeEventListener('touchend', input.ontouchend);

    		existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
    	}
	}

	window.onblur = null;

	clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
	[
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,0,0,0,0,0,0,0,
		1,0,0,0,0,0,0,1,
		1,1,1,0,0,1,1,1,
		1,1,1,1,1,0,0,1,
		1,1,1,1,1,0,0,1,
		1,1,1,0,0,1,1,1,
		1,0,0,0,0,0,0,1,
		0,0,0,0,0,0,0,0,
	]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
	//create image
	var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
	//draw image
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			var i = (y * 8) + x;
			if (loading_anim_data[loading_anim_frame][i] == 1) {
				//scaling nonsense
				for (var sy = 0; sy < scale; sy++) {
					for (var sx = 0; sx < scale; sx++) {
						var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
						loadingAnimImg.data[pxl+0] = 255;
						loadingAnimImg.data[pxl+1] = 255;
						loadingAnimImg.data[pxl+2] = 255;
						loadingAnimImg.data[pxl+3] = 255;
					}
				}
			}
		}
	}
	//put image on canvas
	ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
	//update frame
	loading_anim_frame++;
	if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function updateLoadingScreen() {
	// TODO : in progress
	ctx.fillStyle = "rgb(0,0,0)";
	ctx.fillRect(0,0,canvas.width,canvas.height);

	loadingAnimation();
	drawSprite( getSpriteImage(sprite["a"],"0",0), 8, 8, ctx );
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	if (curRoom == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(deltaTime);
	}
	else {
		if (!isNarrating && !isEnding) {
			updateAnimation();
			drawRoom( room[curRoom] ); // draw world if game has begun
		}
		else {
			//make sure to still clear screen
			ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
			ctx.fillRect(0,0,canvas.width,canvas.height);
		}

		// if (isDialogMode) { // dialog mode
		if(dialogBuffer.IsActive()) {
			dialogRenderer.Draw( dialogBuffer, deltaTime );
			dialogBuffer.Update( deltaTime );
		}
		else if (!isEnding) {
			moveSprites(); // TODO : I probably need to remove this..
		}

		// keep moving avatar if player holds down button
		if( !dialogBuffer.IsActive() && !isEnding )
		{
			if( curPlayerDirection != Direction.None ) {
				playerHoldToMoveTimer -= deltaTime;

				if( playerHoldToMoveTimer <= 0 )
				{
					movePlayer( curPlayerDirection );
					playerHoldToMoveTimer = 150;
				}
			}
		}
	}

	prevTime = curTime;

	//for gif recording
	if (didPlayerMoveThisFrame && onPlayerMoved != null) {
		onPlayerMoved();
	}
	didPlayerMoveThisFrame = false;

	/* hacky replacement */
	if (onDialogUpdate != null) {
		dialogRenderer.SetPageFinishHandler( onDialogUpdate );
	}

	input.resetKeyPressed();
	input.resetTapReleased();
}

function updateInput() {
	if( dialogBuffer.IsActive() ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if(!hasMoreDialog) {
					// ignore currently held keys UNTIL they are released (stops player from insta-moving)
					input.ignoreHeldKeys();
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
	}
	else if ( isEnding ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if ( input.isKeyDown( key.left ) || input.isKeyDown( key.a ) || input.swipeLeft() ) {
			curPlayerDirection = Direction.Left;
		}
		else if ( input.isKeyDown( key.right ) || input.isKeyDown( key.d ) || input.swipeRight() ) {
			curPlayerDirection = Direction.Right;
		}
		else if ( input.isKeyDown( key.up ) || input.isKeyDown( key.w ) || input.swipeUp() ) {
			curPlayerDirection = Direction.Up;
		}
		else if ( input.isKeyDown( key.down ) || input.isKeyDown( key.s ) || input.swipeDown() ) {
			curPlayerDirection = Direction.Down;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer( curPlayerDirection );
			playerHoldToMoveTimer = 500;
		}
	}
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

var moveCounter = 0;
var moveTime = 200;
function moveSprites() {
	moveCounter += deltaTime;

	if (moveCounter >= moveTime) {

		for (id in sprite) {
			var spr = sprite[id];
			if (spr.walkingPath.length > 0) {
				//move sprite
				var nextPos = spr.walkingPath.shift();
				spr.x = nextPos.x;
				spr.y = nextPos.y;


				var end = getEnding( spr.room, spr.x, spr.y );
				var ext = getExit( spr.room, spr.x, spr.y );
				var itmIndex = getItemIndex( spr.room, spr.x, spr.y );
				if (end) { //if the sprite hits an ending
					if (id === playerId) { // only the player can end the game
						startNarrating( ending[end.id], true /*isEnding*/ );
					}
				}
				else if (ext) { //if the sprite hits an exit
					//move it to another scene
					spr.room = ext.dest.room;
					spr.x = ext.dest.x;
					spr.y = ext.dest.y;
					if (id === playerId) {
						//if the player changes scenes, change the visible scene
						curRoom = ext.dest.room;
					}
				}
				else if(itmIndex > -1) {
					var itm = room[ spr.room ].items[ itmIndex ];
					room[ spr.room ].items.splice( itmIndex, 1 );
					if( spr.inventory[ itm.id ] ) {
						spr.inventory[ itm.id ] += 1;
					}
					else {
						spr.inventory[ itm.id ] = 1;
					}

					if (onInventoryChanged != null) {
						onInventoryChanged( itm.id );
					}

					if (id === playerId) {
						startItemDialog( itm.id  /*itemId*/ );
					}

					// stop moving : is this a good idea?
					spr.walkingPath = [];
				}

				if (id === playerId) didPlayerMoveThisFrame = true;
			}
		}

		moveCounter = 0;
	}

}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var newKeyPress;
	var touchState;

	function resetAll() {
		pressed = {};
		ignored = {};
		newKeyPress = false;

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : Direction.None,
			tapReleased : false
		};
	}
	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function tryRestartGame(e) {
		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// console.log("IGNORE -- " + key);
			}
		}
	}

	this.onkeydown = function(event) {
		// console.log("KEYDOWN -- " + event.keyCode);

		stopWindowScrolling(event);

		tryRestartGame(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		if (!self.isKeyDown(event.keyCode)) {
			newKeyPress = true;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// console.log("KEYUP -- " + event.keyCode);
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = Direction.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == Direction.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = Direction.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyPressed = function() {
		return newKeyPress;
	}

	this.resetKeyPressed = function() {
		newKeyPress = false;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == Direction.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == Direction.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == Direction.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == Direction.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// console.log("~~~ BLUR ~~");
		resetAll();
	}
}
var input = null;

function movePlayer(direction) {
	if (player().room == null || !Object.keys(room).includes(player().room)) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
		didPlayerMoveThisFrame = true;
	}
	
	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	// TODO : vNext
	// var eff = getEffect( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		// TODO pick up items (what about touch?)
		// console.log("HIT ITM ");
		// console.log( itmIndex );
		var itm = room[ player().room ].items[ itmIndex ];
		// console.log(itm);
		room[ player().room ].items.splice( itmIndex, 1 );
		if( player().inventory[ itm.id ] ) {
			player().inventory[ itm.id ] += 1;
		}
		else {
			player().inventory[ itm.id ] = 1;
		}

		if(onInventoryChanged != null) {
			onInventoryChanged( itm.id );
		}

		startItemDialog( itm.id  /*itemId*/ );

		// console.log( player().inventory );
	}

	if (end) {
		startNarrating( ending[end.id], true /*isEnding*/ );
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	// TODO : vNext
	// else if (eff) {
	// 	startDialog( script[eff.id].source, eff.id );
	// }
	else if (spr) {
		startSpriteDialog( spr /*spriteId*/ );
	}
}

var transition = new TransitionManager();

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (ext.transition_effect != null) {
			transition.BeginTransition(player().room, player().x, player().y, ext.dest.room, ext.dest.x, ext.dest.y, ext.transition_effect);
			transition.UpdateTransition(0);
		}

		player().room = ext.dest.room;
		player().x = ext.dest.x;
		player().y = ext.dest.y;
		curRoom = ext.dest.room;
	};

	// TODO : vNext
	// if(ext.script_id != null && script[ext.script_id]){
	// 	var scriptSourceStr = script[ext.script_id].source;
	// 	startDialog(scriptSourceStr, ext.script_id, function(isExitUnlocked) {
	// 		if (isExitUnlocked == true) {
	// 			GoToDest();
	// 		}
	// 	});
	// }
	// else {
	// 	GoToDest();
	// }

	GoToDest();
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
	if(roomId == undefined || roomId == null)
		roomId = curRoom;

	var tileId = getTile( x, y );

	if( tileId === '0' )
		return false; // Blank spaces aren't walls, ya doofus

	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf( getTile(x,y) );
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

// TODO : vNext
// function getEffect(roomId,x,y) {
// 	for (i in room[roomId].effects) {
// 		var e = room[roomId].effects[i];
// 		if (x == e.x && y == e.y) {
// 			return e;
// 		}
// 	}
// 	return null;
// }

function getTile(x,y) {
	// console.log(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	// console.log("~~~ PARSE WORLD ~~~");
	// console.log(file);

	// var parseTimer = new Timer();

	spriteStartLocations = {};

	resetFlags();

	var versionNumber = 0;

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number (from a comment.. hacky I know)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i);
		}
		else if (getType(curLine) === "END") {
			i = parseEnding(lines, i);
		}
		// TODO: vNext
		// else if (getType(curLine) === "PRG") {
		// 	i = parseScript(lines, i);
		// }
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(lines, i);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}

	placeSprites();

	var roomIds = Object.keys(room);
	if (player() != undefined && player().room != null && roomIds.includes(player().room)) {
		// player has valid room
		curRoom = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		curRoom = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		curRoom = null;
	}

	console.log("START ROOM " + curRoom);

	renderer.SetPalettes(palette);

	// console.log(names);

	// console.log("~~~~~ PARSE TIME " + parseTimer.Milliseconds());

	return versionNumber;
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null)
		skipFonts = false;

	var worldStr = "";
	/* TITLE */
	worldStr += title + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			if( palette[id].name != null )
				worldStr += "NAME " + palette[id].name + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					// TODO : vNext
					// if (e.script_id != undefined && e.script_id != null) {
					// 	worldStr += " PRG " + e.script_id;
					// }
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		// TODO : vNext
		// if (room[id].effects.length > 0) {
		// 	/* EFFECTS */
		// 	for (j in room[id].effects) {
		// 		var e = room[id].effects[j];
		// 		worldStr += "EFF " + e.id + " " + e.x + "," + e.y;
		// 		worldStr += "\n";
		// 	}
		// }
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		worldStr += "DLG " + id + "\n";
		worldStr += dialog[id] + "\n";
		worldStr += "\n";
	}
	/* ENDINGS */
	for (id in ending) {
		worldStr += "END " + id + "\n";
		worldStr += ending[id] + "\n";
		worldStr += "\n";
	}
	// TODO : vNext
	// /* SCRIPTS */
	// for (id in script) {
	// 	if (script[id].type == ScriptType.Dialogue) {
	// 		worldStr += "DLG " + id + "\n";
	// 	}
	// 	else if (script[id].type == ScriptType.Ending) {
	// 		worldStr += "END " + id + "\n";
	// 	}
	// 	else {
	// 		worldStr += "PRG " + id + "\n";
	// 	}
	// 	worldStr += script[id].source + "\n";
	// 	worldStr += "\n";
	// }
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	var imageSource = renderer.GetImageSource(drwId);
	var drwStr = "";
	for (f in imageSource) {
		for (y in imageSource[f]) {
			var rowStr = "";
			for (x in imageSource[f][y]) {
				rowStr += imageSource[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (imageSource.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//console.log(id);
		//console.log( spriteStartLocations[id] );
		//console.log(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//console.log(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	title = lines[i];
	i++;
	return i;
}

function parseRoom(lines, i) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		// effects : [], // TODO vNext
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// console.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				},
				transition_effect : null,
				// TODO : vNext
				// script_id : null,
			};

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				// TODO : vNext
				// else if (exitArgs[exitArgIndex] == "PRG") {
				// 	ext.script_id = exitArgs[exitArgIndex+1];
				// 	exitArgIndex += 2;
				// }
				else {
					exitArgIndex += 1;
				}
			}

			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId( lines[i] );
			var endCoords = getCoord( lines[i], 2 );
			var end = {
				id : endId,
				x : parseInt( endCoords[0] ),
				y : parseInt( endCoords[1] )
			};
			room[id].endings.push(end);
		}
		// TODO : vNext
		// else if (getType(lines[i]) === "EFF") {
		// 	/* ADD EFFECT */
		// 	var effectId = getId( lines[i] );
		// 	var effectCoords = getCoord( lines[i], 2 );
		// 	var effect = {
		// 		id : effectId,
		// 		x : parseInt( effectCoords[0] ),
		// 		y : parseInt( effectCoords[1] ),
		// 	};
		// 	room[id].effects.push(effect);
		// }
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room.set( name, id);
		}
		i++;
	}
	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if(args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store tile source
		drwId = "TIL_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 1; // default palette color index is 1
	var isWall = null; // null indicates it can vary from room to room (original version)
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.tile.set( name, id );
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg( lines[i], 1 );
			if( wallArg === "true" ) {
				isWall = true;
			}
			else if( wallArg === "false" ) {
				isWall = false;
			}
		}
		i++;
	}

	//tile data
	tile[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name,
		isWall : isWall
	};

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store sprite source
		drwId = "SPR_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	var startingInventory = {};
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.sprite.set( name, id );
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat( getArg(lines[i], 2) );
			startingInventory[itemId] = itemCount;
		}
		i++;
	}

	//sprite data
	sprite[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		room : null, //default location is "offstage"
		x : -1,
		y : -1,
		walkingPath : [], //tile by tile movement path (isn't saved)
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		inventory : startingInventory,
		name : name
	};
	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store item source
		drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getArg( lines[i], 1 ) );
		}
		// else if (getType(lines[i]) === "POS") {
		// 	/* STARTING POSITION */
		// 	var posArgs = lines[i].split(" ");
		// 	var roomId = posArgs[1];
		// 	var coordArgs = posArgs[2].split(",");
		// 	spriteStartLocations[id] = {
		// 		room : roomId,
		// 		x : parseInt(coordArgs[0]),
		// 		y : parseInt(coordArgs[1])
		// 	};
		// }
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.item.set( name, id );
		}
		i++;
	}

	//item data
	item[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		// room : null, //default location is "offstage"
		// x : -1,
		// y : -1,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name
	};

	// console.log("ITM " + id);
	// console.log(item[id]);

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		frameList[frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				frameList.push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	renderer.SetImageSource(drwId, frameList);

	return i;
}

// TODO : vNext
// var ScriptType = {
// 	Script : 0,
// 	Dialogue : 1, // TODO : move everything to this spelling?
// 	Ending : 2,
// };

function parseScript(lines, i, objectStore) {
	// TODO : vNext
	// if (scriptType === undefined || scriptType === null) {
	// 	scriptType = ScriptType.Script;
	// }

	var id = getId(lines[i]);
	i++;

	var results = scriptUtils.ReadDialogScript(lines,i);

	// TODO : vNext
	// script[id] = {
	// 	source: results.script,
	// 	type: scriptType,
	// };

	objectStore[id] = results.script;

	i = results.index;

	return i;
}

function parseDialog(lines, i) {
	return parseScript(lines, i, dialog);
}

function parseEnding(lines, i) {
	return parseScript(lines, i, ending);
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(lines, i) {
	textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(img,x,y,context) {
	if (!context) { //optional pass in context; otherwise, use default
		context = ctx;
	}
	// NOTE: images are now canvases, instead of raw image data (for chrome performance reasons)
	context.drawImage(img,x*tilesize*scale,y*tilesize*scale,tilesize*scale,tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
	drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
	drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

// var debugLastRoomDrawn = "0";

function drawRoom(room,context,frameIndex) { // context & frameIndex are optional
	if (!context) { //optional pass in context; otherwise, use default (ok this is REAL hacky isn't it)
		context = ctx;
	}

	// if (room.id != debugLastRoomDrawn) {
	// 	debugLastRoomDrawn = room.id;
	// 	console.log("DRAW ROOM " + debugLastRoomDrawn);
	// }

	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		context.fillStyle = "rgb(" + getPal(paletteId)[0][0] + "," + getPal(paletteId)[0][1] + "," + getPal(paletteId)[0][2] + ")";
		context.fillRect(0,0,canvas.width,canvas.height);
		return;
	}

	//clear screen
	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}
	context.fillStyle = "rgb(" + getPal(paletteId)[0][0] + "," + getPal(paletteId)[0][1] + "," + getPal(paletteId)[0][2] + ")";
	context.fillRect(0,0,canvas.width,canvas.height);

	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			if (id != "0") {
				//console.log(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// console.log(id);
					drawTile( getTileImage(tile[id],paletteId,frameIndex), j, i, context );
				}
			}
		}
	}

	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem( getItemImage(item[itm.id],paletteId,frameIndex), itm.x, itm.y, context );
	}

	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite( getSpriteImage(spr,paletteId,frameIndex), spr.x, spr.y, context );
		}
	}
}

// TODO : remove these get*Image methods
function getTileImage(t,palId,frameIndex) {
	return renderer.GetImage(t,palId,frameIndex);
}

function getSpriteImage(s,palId,frameIndex) {
	return renderer.GetImage(s,palId,frameIndex);
}

function getItemImage(itm,palId,frameIndex) {
	return renderer.GetImage(itm,palId,frameIndex);
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

function onExitDialog(scriptResult, dialogCallback) {
	isDialogMode = false;
	if (isNarrating) isNarrating = false;
	if (isDialogPreview) {
		isDialogPreview = false;
		if (onDialogPreviewEnd != null)
			onDialogPreviewEnd();
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	console.log("NARRATE " + dialogStr);

	if(end === undefined) end = false;

	isNarrating = true;
	isEnding = end;
	startDialog(dialogStr);
}

function startItemDialog(itemId) {
	var dialogId = item[itemId].dlg;
	// console.log("START ITEM DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg ? spr.dlg : spriteId;
	// console.log("START SPRITE DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr,scriptId,dialogCallback) {
	// console.log("START DIALOG ");
	if(dialogStr.length <= 0) {
		// console.log("ON EXIT DIALOG -- startDialog 1");
		onExitDialog(dialogCallback);
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( isNarrating /*centered*/ );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if(scriptId === undefined) {
		scriptInterpreter.Interpret( dialogStr, onScriptEnd );
	}
	else {
		if( !scriptInterpreter.HasScript(scriptId) ) {
			scriptInterpreter.Compile( scriptId, dialogStr );
		}
		scriptInterpreter.DebugVisualizeScriptTree(scriptId);
		scriptInterpreter.Run( scriptId, onScriptEnd );
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, onScriptEnd) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( true );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	onDialogPreviewEnd = onScriptEnd;

	scriptInterpreter.Eval( script, null );
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
</script>

<!-- Borksy modification: uses better encoded default font. -->
<script type="bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 162
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 163
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 165
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 167
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 171
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 172
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 177
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 178
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 187
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 188
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 189
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 191
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 196
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 197
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 198
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 199
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 201
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 209
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 214
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 223
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 224
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 225
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 226
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 230
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 231
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 232
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 233
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 234
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 235
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 236
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 237
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 238
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 239
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 242
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 243
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 244
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 246
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 247
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 249
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 250
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 251
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 252
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 255
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 402
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 915
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 920
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 931
011111
010000
001000
000100
001000
010000
011111
000000
CHAR 934
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 937
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 948
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 949
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 960
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 963
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 964
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 966
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 8226
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8252
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 8592
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 8593
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 8594
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 8595
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 8734
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 8735
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 8801
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 8804
000010
001100
010000
001100
000010
000000
011110
000000
CHAR 8805
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 8962
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 8976
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 9472
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9552
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 9553
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 9556
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 9557
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 9558
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 9559
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 9561
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 9562
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 9563
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 9564
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 9565
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 9566
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 9567
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 9568
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 9569
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 9570
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 9571
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 9572
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 9573
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 9574
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 9575
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 9576
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 9577
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 9580
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9617
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 9619
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9644
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 9650
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 9658
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 9660
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 9668
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 9675
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 9688
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9689
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 9786
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 9787
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 9788
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 9792
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 9794
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 9824
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 9827
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 9829
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 9830
000000
000100
001110
011111
011111
001110
000100
000000
CHAR 9834
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 9835
000011
001101
001011
001101
001011
011011
011000
000000
</script>

<!-- BORKSY HACKS -->
<script type="text/javascript" id="borksyHacks">
//borksy uses dist versions of hacks from the bitsy hacks repo now

/**
🔚
@file end-from-dialog
@summary trigger an ending from dialog, including narration text
@license WTFPL (do WTF you want)
@version 3.3.4
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
Lets you end the game from dialog (including inside conditionals).

Using the (end) function in any part of a series of dialog will make the
game end after the dialog is finished. Ending the game resets it back to the
intro.

If the text provided as an argument is a valid ending id,
the corresponding ending text will be shown.
If not, the text provided will be used directly as ending text.

Using (endNow) at the end of a sentence will display the whole sentence and
immediately clear the background. No further dialog from that passage will
display, and the game will reset when you proceed. Using (endNow) with
narration text will immediately exit the dialog, clear the background, and
show the ending narration in an ending-style centered dialog box.

Usage: (end)
       (end "<ending id>")
       (end "<ending narration>")
       (endNow)
       (endNow "<ending id>")
       (endNow "<ending narration>")

Example: (end)
         (end "Five friars bid you goodbye. You leave the temple, hopeful.")
         (endNow "The computer is still online! The chamber floods with neurotoxin.")

HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
     It should appear *before* any other mods that handle loading your game
     data so it executes *after* them (last-in first-out).

NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.

      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/
(function (bitsy) {
'use strict';

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchRegex + '" in script tags';
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 4.0.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	kitsy.queuedInjectScripts.push({
		searchRegex: searchRegex,
		replaceString: replaceString
	});
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				returnVal = functions[i++].apply(this, args);
				if (returnVal && returnVal.length) {
					args = returnVal;
				}
				return runBefore.apply(this, args);
			}
		}

		return runBefore.apply(this, arguments);
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".+?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}


function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		throw new Error('The dialog function "' + tag + '" already exists.');
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (game_data) {
		return [convertDialogTags(game_data, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", kitsy.dialogFunctions.' + tag + ');'
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", function(e, p, o){ kitsy.deferredDialogFunctions.' + tag + '.push({e:e,p:p}); o(null); });'
	);
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}



// Implement the dialog functions
addDualDialogTag('end', function (environment, parameters) {
	bitsy.dialogBuffer.EndDialog();
	bitsy.startNarrating(bitsy.ending[parameters[0]] || parameters[0] || '', true);
});
// End of (end) dialog function mod

}(window));



</script>

<script type="text/javascript" id="borksyAdditionalJS">

</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
<!-- GAME CANVAS -->
<canvas id='game'></canvas>
</body>


</html>